## Algorithm Problem Solving

**05/05/2023**


### [Q2580] - 统计将重叠区间合并成组的方案数
#### Solution:

- Key word：合并->(并查集)，这里提到区间->区间合并
- High Level:
  > 求集合的个数m, 集合是有交集的区间
  > 方案数: 2 ^ m
  > 求区间的交集，
  > - 区间左端点排序
  > - 遍历区间，维护右端点的最大值 max_r，如果当前区间的左端点大于右端点的最大值，说明当前区间和前面的区间没有交集，m += 1

- Algorithm Knowledge:
  > 区间合并 [Q56]

- Code Tricks:
  > 最后求方案数的时候，用快速幂，避免溢出。
  > pow(2, m, 10 ** 9 + 7)


#### Code:
```python
class Solution:
    def countWays(self, ranges: List[List[int]]) -> int:
        ranges.sort(key=lambda p: p[0])
        m = 1
        max_r = ranges[0][1]
        for l, r in ranges:
            if l > max_r:
                m += 1
            max_r = max(max_r, r)
        return pow(2, m, 10 ** 9 + 7) # 快速幂
```
[Q56] - 区间合并
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        ans = []
        intervals.sort(key=lambda p: p[0])
        # 初始区间
        start, max_r = intervals[0]
        # 遍历区间
        for l, r in intervals:
            # 如果当前区间的左端点大于右端点的最大值，说明当前区间和前面的区间没有交集
            if l > max_r:
                ans.append([start, max_r])
                # 更新区间的起点
                start = l 
            max_r = max(max_r, r)
        # 最后一个区间
        ans.append([start, max_r])
        return ans 
```


```java
```

### [Q2581] - 统计可能的树根数目

#### Solution:

- High Level:
  > 1. 如果只求以0为根时DFS求出猜对次数cnt0
  > 2. 换根DP，再跑一次DFS，0->1， cnt0 - (0,1) in s + (1,0) in s，思想就是算出增量。减去(0,1)就是错误的猜测，增加(1,0)就是正确的猜测。

- Algorithm Knowledge:
  > 换根DP - 换一个根节点，求以新的根节点对于答案的贡献的变化
  > **拓展**： 如果换成x是y的祖先节点，而不是父节点。该如何思考？
  > - 子树y中有多少个x(猜测中的)子孙
  > - 除了


- Code Tricks:
  > Python: 使用元祖作为字典的key
  > C++/Java: ((long) a << 32 | b) 作为key，将2个4个字节的数，变成一个8个字节的数，可以作为key放在哈希表中

#### Code:

```python
class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        g = [[] for _ in range(len(edges) + 1)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
        
        s = {(x, y) for x, y in guesses}
        # Java C++, set<long> add((long)x << 32 | y) 4个字节2个数拼成1一个8个字节得数
        # Go pair{x, y int}

        cnt0 = 0
        # 遍历树模板
        def dfs(x: int, fa: int) -> None:
            nonlocal cnt0
            for y in g[x]:
                if y == fa:
                    continue
                if (x, y) in s:
                    cnt0 += 1
                dfs(y, x) 
        dfs(0, -1)

        ans = 0
        # 换根
        def reroot(x: int, fa: int, cnt: int) -> None:
            # cnt 以x为根时猜对的次数
            nonlocal ans 
            if cnt >= k:
                ans += 1 
            for y in g[x]:
                if y == fa:
                    continue
                # delta = - (x,y) + (y,x)
                reroot(y, x, cnt - ((x, y) in s) + ((y, x) in s))
        reroot(0, -1, cnt0)        
        return ans 
```


#### Java

```java
```

#### Related problems:

- [Q56] - 区间合并

## Go
**Go! Grow together**

[//]: # (These are reference links used in the body of this note and get stripped out when the markdown processor does its job. There is no need to format nicely because it shouldn't be seen. Thanks SO -     http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax)
   [Q2580]: <https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/>
   [Q56]: <https://leetcode.cn/problems/merge-intervals/>
   [Q2581]: <https://leetcode.cn/problems/count-number-of-possible-root-nodes/solutions/>