### Trie

**07/17/2023**

#### 核心思想
> 是用空间换时间的数据结构。主要应用场景用于
>  - 处理共同前缀，统计，排序，和保存大量字符串。用于字符串检索，**字符串最长公共前缀，前缀匹配**。
>  - **01字典**，用于处理异或最值问题。
> 优点:利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。节省存储空间，公共前缀共享同样的前缀。
> 三个重要的性质:
>  - 根节点不包含任何字符，字符存在边上。
>  - 从根节点到某个节点，经过的路径就是字符串。
>  - 每个节点的孩子都不同，对应单词和字符是唯一的。

#### 代码模板
>

```python
class Node:
    __slots__ = 'son', 'is_word'

    def __init__(self):
        # 儿子节点都是字典，不用数组26来实现
        self.son = defaultdict(Node)
        self.is_word = False

class Trie:

    def __init__(self):
        self.root = Node()

    def insert(self, word: str) -> None:
        cur = self.root 
        for c in word:
            cur = cur.son[c]
        cur.is_word = True 

    def search(self, word: str) -> bool:
        cur = self.root 
        for c in word:
            if c not in cur.son:
                return False 
            cur = cur.son[c]
        return cur.is_word

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.son:
                return False 
            cur = cur.son[c]
        return True 
```

#### 相关问题

[Q208] Implement Trie (Prefix Tree)
> - 关键字，前缀/后缀。Trie特别适合维护很多字符串的前缀或后缀信息
> - 模板题
> - 时间复杂度O(n)

```python
class Node:
    __slot__ = 'son', 'is_word'

    def __init__(self):
        self.son = defaultdict(Node)
        self.is_word = False
        

class Trie:

    def __init__(self):
        self.root = Node()
        

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            cur = cur.son[c]
        cur.is_word = True 
        

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if c not in cur.son:
                return False
            cur = cur.son[c]
        return cur.is_word
        

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.son:
                return False 
            cur = cur.son[c]
        return True
```

[Q676] Implement Magic Dictionary
> - 关键字，改变一个字符，在字符串集合中查找字符串，本质上是查找字符串个数。并且多次询问。Trie非常擅长处理词频统计。
> - 本质上，是在Trie树上统计一些信息，统计的就是改变一个字符的情况下，是否有一个字符串可以匹配。在树上做dfs即可。
> - 时间复杂度: O($C^L$)
> - 空间复杂度: O($N \times L \times C$) $N = 100$ 存入Trie最多个数，$L = 100$ 存入字符串的最大长度，$C = 26$ 为字符集大小。

```python
class Node:
    __slot__ = 'son', 'is_word'

    def __init__(self):
        self.son = defaultdict(Node)
        self.is_word = False


class MagicDictionary:

    def __init__(self):
        self.root = Node()

    
    def insert(self, word):
        cur = self.root
        for c in word:
            cur = cur.son[c]
        cur.is_word = True 
        

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            self.insert(word)
        

    def search(self, searchWord: str) -> bool:
        def dfs(s, node, i, cnt):
            if node.is_word and i == len(s) and cnt == 1:
                return True
            
            if i == len(s) or cnt > 1:
                return False

            for c in node.son.keys():
                if dfs(s, node.son[c], i + 1, cnt + (c != s[i])):
                    return True 
            return False

        return dfs(searchWord, self.root, 0, 0)
```
[Q648] - Replace Words
> 使用最短前缀来取代单词，适合使用Trie来解决。
> 使用一个idx来维护原有字典内的单词的下标。

```python
class Node:
    __slot__ = 'son', 'idx'

    def __init__(self):
        self.son = defaultdict(Node)
        self.idx = -1

class Trie:

    def __init__(self):
        self.root = Node()
    
    def insert(self, word: str, idx: int) -> None:
        cur = self.root
        for c in word:
            cur = cur.son[c]
        cur.idx = idx

    def startWith(self, word: str) -> int:
        cur = self.root
        for c in word:
            cur = cur.son[c]
            if cur.idx != -1:
                return cur.idx
        return -1


class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for i, word in enumerate(dictionary):
            trie.insert(word, i)
        ans = []
        for word in sentence.split(' '):
            idx = trie.startWith(word)
            if idx != -1:
                word = dictionary[idx] 
            ans.append(word)
        return ' '.join(ans)
```

[Q139] 

[Q421] - Maximum XOR of Two Numbers in an Array
> 对于每一位，我们可以考虑是否可以找出2个数使得最高位为1。`x^y=1`，这个可以用经典的两数之和解决。
> 每次只看一位，1000..00, 1100..00，每次看枚举的位置是否可以找到两个数，使得当前位为1。
> 其中用到位运算的常用技巧。
> 

```python
class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        ans = mask = 0
        high_bit = max(nums).bit_length() - 1
        for i in range(high_bit, -1, -1):
            mask |= 1 << i # 当前位置为1
            new_ans = ans | (1 << i) # 假设这位可以为1
            # 两数之和
            seen = set()
            for x in nums:
                x &= mask # 低于i的比特位变成0
                if new_ans ^ x in seen: # 是否有两个数异或和为new_ans
                    ans = new_ans
                    break
                seen.add(x)
        return ans 
```

[Q2935] - Maximum XOR With an Element From Array
>

```python
class Node:
    __slots__ = 'children', 'cnt'

    def __init__(self):
        self.children = [None, None]
        self.cnt = 0

class Trie:
    HIGH_BIT = 19

    def __init__(self):
        self.root = Node()

    
    def insert(self, x):
        cur = self.root
        for i in range(Trie.HIGH_BIT, -1, -1):
            bit = (x >> i) & 1
            if cur.children[bit] is None:
                cur.children[bit] = Node()
            cur = cur.children[bit]
            cur.cnt += 1 # 维护子树大小, 为了remove节点
    

    def remove(self, x):
        cur = self.root
        for i in range(Trie.HIGH_BIT, -1, -1):
            cur = cur.children[(x >> i) & 1]
            cur.cnt -= 1
    

    def max_xor(self, x):
        cur = self.root 
        ans = 0
        for i in range(Trie.HIGH_BIT, -1, -1):
            bit = (x >> i) & 1
            # cur.children[bit^1].cnt == 0, 视为空节点
            # 很精妙，bit=0去找1，0^1=1, bit=1去找0, 1^1=0,常用技巧
            if cur.children[bit ^ 1] and cur.children[bit ^ 1].cnt:
                ans |= 1 << i 
                bit ^= 1 # 可以选取对立，选取对立的数字的路径
            cur = cur.children[bit] # 没有对立数字，只能走当前路径
        return ans 


class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        nums.sort()
        t = Trie()
        ans = left = 0
        for y in nums: # 滑动窗口模板
            t.insert(y)
            while nums[left] * 2 < y: 
                t.remove(nums[left])
                left += 1 
            ans = max(ans, t.max_xor(y))
        return ans 
```

```cpp
class Node {
public:
    array<Node*, 2> children{};
    int cnt{0};
};

class Trie {
    static const int HIGH_BIT = 19;
public:
    Node* root = new Node();

    void insert(int x) {
        Node* cur = root;
        for (int i = HIGH_BIT; ~i; i -- ) {
            int bit = (x >> i) & 1;
            if (cur->children[bit] == nullptr)
                cur->children[bit] = new Node();
            cur = cur->children[bit];
            cur->cnt ++;
        }
    }

    void remove(int x) {
        Node* cur = root;
        for (int i = HIGH_BIT; ~i; i -- ) {
            int bit = (x >> i) & 1;
            cur = cur->children[bit];
            cur->cnt -- ;
        }
    }

    int max_xor(int x) {
        Node* cur = root;
        int ans{0};
        
        for (int i = HIGH_BIT; ~i; i -- ) {
            int bit = (x >> i) & 1;
            if (cur->children[bit ^ 1] && cur->children[bit ^ 1]->cnt) {
                ans |= 1 << i;
                bit ^= 1;
            }
            cur = cur->children[bit];
        }
        return ans;
    }
};

class Solution {
public:
    int maximumStrongPairXor(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        Trie t{};
        int ans = 0, left = 0;
        for (int y: nums) {
            t.insert(y);
            while (nums[left] * 2 < y)
                t.remove(nums[left ++ ]);
            ans = max(ans, t.max_xor(y));
        }

        return ans;
    }
};
```

[//]: # 
   [Q208]: <https://leetcode.com/problems/implement-trie-prefix-tree/>
   [Q139]: <https://leetcode.com/problems/word-break/>
   [Q676]: <https://leetcode.com/problems/implement-magic-dictionary/description/>
   [Q648]: <https://leetcode.com/problems/replace-words/description/>
   [Q421]: <https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/>
   [Q2935]: <https://leetcode.com/problems/maximum-xor-with-an-element-from-array/description/>
