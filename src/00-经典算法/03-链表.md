#### 链表

**07/20/2023**

#### 核心思想

> 链表的基本操作，增删改查。
> 算法基本是模拟，注意边界条件。处理边界条件的时候，可以在链表头部加一个保护节点，这样就不用单独处理头节点了。
> 翻转链表，迭代结束后，**`pre`指向的是头节点，`cur`指向的是`None`**。

#### 相关问题

[Q206] Reverse Linked List

> -   反转链表，迭代和递归两种方法。
> -   时间复杂度: $`O(n)`$，其中 n 为链表长度。
> -   空间复杂度: $`O(1)`$。

-   迭代写法

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur = None, head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```

[Q92] Reverse Linked List II

> 翻转中间一段后利用`pre`指向的是反转后一段的头结点，`cur`指向的是反转后一段的尾节点，将两段拼接起来。
> 处理边界，`left=1`的情况，可以在链表头部加一个保护节点(哨兵)，这样就不用单独处理头节点了。

```python
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        dummy = ListNode(next=head)
        p0 = dummy
        # find the previous node at left
        for _ in range(left - 1):
            p0 = p0.next
        # reverse the list in range [left,right]
        pre, cur = p0, p0.next
        for _ in range(right - left + 1):
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        # concat the lists
        p0.next.next = cur
        p0.next = pre

        return dummy.next
```

[Q25] Reverse Nodes in k-Group

> 链表翻转模板，注意每`k`个翻转，最后不足`k`个的不翻转。所以先计算链表的长度。
> 然后利用链表翻转模板，`pre`指向每一段的头结点，`cur`指向每一段尾节点的下一个节点。和前一段进行拼接即可。

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # get the length of list
        n = 0
        cur = head
        while cur:
            n += 1
            cur = cur.next

        # reverse list for each group
        dummy = ListNode(next=head)
        p0 = dummy
        pre = None
        cur = p0.next
        while n >= k:
            n -= k
            for _ in range(k):
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt

            nxt = p0.next
            p0.next.next = cur
            p0.next = pre
            p0 = nxt # pre node at next group of k nodes
        return dummy.next
```

[Q2] Add Two Numbers

> -   两个链表相加，类似于高精度加法运算的算法。都累加到进位上。
> -   利用保护节点 head，简化代码。
> -   时间复杂度: $`O(n)`$，其中 n 为链表长度。
> -   空间复杂度: $`O(1)`$。

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        t = 0
        p1, p2 = l1, l2
        tail = head = ListNode(-1)
        while p1 or p2:
            if p1:
                t += p1.val
                p1 = p1.next
            if p2:
                t += p2.val
                p2 = p2.next
            tail.next = ListNode(t % 10)
            tail = tail.next
            t //= 10
        if t:
            tail.next = ListNode(t)
        return head.next
```

[Q445] - Add Two Numbers II

> -   这道题是[Q206] + [Q2]的结合，先反转链表，然后相加，最后再反转回来。
> -   时间复杂度: $`O(n)`$，其中 n 为链表长度。
> -   空间复杂度: $`O(1)`$。

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre


    def addTwo(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = cur = ListNode()
        carry = 0
        while l1 or l2 or carry:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
            cur.next = ListNode(carry % 10)
            carry //= 10
            cur = cur.next
        return dummy.next


    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        l1 = self.reverseList(l1)
        l2 = self.reverseList(l2)
        l3 = self.addTwo(l1, l2)
        return self.reverseList(l3)
```

[Q2816] Double a Number Represented as a Linked List

> -   这道题是[Q445]的变形，相当于自己加自己。可以直接过掉。方法 II，考虑进位问题，看下一个数字是否>=5， 当前数位+1
> -   时间复杂度: $`O(n)`$，其中 n 为链表长度。

```python
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val >= 5:
            head = ListNode(0, head)
        cur = head
        while cur:
            cur.val = cur.val * 2 % 10
            if cur.next and cur.next.val >= 5: # 下个节点>=5进位
                cur.val += 1
            cur = cur.next
        return head
```

[//]: #
[Q2]: https://leetcode.com/problems/add-two-numbers/
[Q92]: https://leetcode.com/problems/reverse-linked-list-ii/
[Q25]: https://leetcode.com/problems/reverse-nodes-in-k-group/
[Q206]: https://leetcode-cn.com/problems/reverse-linked-list/
[Q445]: https://leetcode.com/problems/add-two-numbers-ii/description/
[Q2816]: https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/
