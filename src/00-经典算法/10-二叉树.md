### 二叉树

**08/17/2023**

#### 核心思想

> 适用的场景，维护二叉树的一些信息。树结构的本身，天然适合使用递归，根节点+左右子树，子树和原问题相同。不要一开始陷入细节，考虑左右子树的关系。
>
> -   DFS 来完成信息的维护，多数情况。多数情况子树向父节点更新信息，少数情况父节点 pushdown 一些信息，来更新子树的信息。
> -   BFS 来完成信息的维护，一般是从上到下，从左到右，一层一层的更新信息。

#### 代码模板

-   DFS

```python
def dfs(node):
    边界条件

    dfs(node.left)
    dfs(node.right)
    更新信息
    return 本层信息给上层

ans = 0 # 全局变量
def dfs(node, params):
    边界条件

    更新信息
    nonlocal ans
    更新ans
    dfs(node.left, params)
    dfs(node.right, params)
dfs(root, params)
return ans
```

-   BFS

```python

```

#### 相关问题

[Q104] - Maximum Depth of Binary Tree

> 递归计算左右子树的最大深度，对于根节点就是左右子树的最大深度 + 1

-   方法 I: 自底向上

```python
class Solution:
def maxDepth(self, root: Optional[TreeNode]) -> int:
    if root is None:
        return 0
    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

-   方法 II: 自顶向下

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(node, cnt):
            if node is None:
                return
            cnt += 1
            nonlocal ans
            ans = max(ans, cnt)
            dfs(node.left, cnt)
            dfs(node.right, cnt)
        dfs(root, 0)
        return ans
```

[Q100] - Same Tree

> 根节点值相同，然后判断左右子树是否相同，边界条件是左右子树都为空

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None or q is None:
            return p is q
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

[Q101] - Symmetric Tree

> 递归判断左右子树是否对称，左子树的左子树和右子树的右子树对称，左子树的右子树和右子树的左子树对称

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def dfs(p, q):
            if p is None or q is None:
                return p is q
            return p.val == q.val and dfs(p.left, q.right) and dfs(p.right, q.left)
        return dfs(root.left, root.right)
```

[Q110] - Balanced Binary Tree

[Q199] - Binary Tree Right Side View

[Q2458] - Height of Binary Tree After Subtree Removal Queries

> 两次 DFS
> 删除子树的时候，需要知道其它子树的高度信息。可以先 DFS，把每棵子树的高度求出来
> 然后再 DFS，向下递归之前，把其余部分的最大高度计算出来

    ```python
    class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        # 1. 求出所有子树的高度
        height = defaultdict(int)
        def get_height(node):
            if node is None:
                return 0
            height[node] = 1 + max(get_height(node.left), get_height(node.right))
            return height[node]
        get_height(root)

        # 2. 再次递归，递归之前，把其余部分的最大高度求出来
        res = [0] * (len(height) + 1) # 每个节点答案
        def dfs(node, depth, rest_h):
            if node is None:
                return

            depth += 1
            res[node.val] = rest_h # 递归之前，求出其余部分的最大高度
            dfs(node.left, depth, max(rest_h, depth + height[node.right]))
            dfs(node.right, depth, max(rest_h, depth + height[node.left]))
        dfs(root, -1, 0) # -1 depth+=1

        for i, q in enumerate(queries):
            queries[i] = res[q]
        return queries
    ```

[//]: #
[Q104]: https://leetcode.com/problems/maximum-depth-of-binary-tree/
[Q100]: https://leetcode.com/problems/same-tree/
[Q101]: https://leetcode.com/problems/symmetric-tree/
[Q110]: https://leetcode.com/problems/balanced-binary-tree/
[Q199]: https://leetcode.com/problems/binary-tree-right-side-view/
[Q2458]: https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/

```

```
