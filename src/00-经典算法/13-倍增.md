### 倍增

**08/27/2023**

#### 核心思想

> 倍增算法，顾名思义，就是不断地翻倍。
> 虽然是一种基础算法，但它能够使得线性的处理转化为对数级的处理，大大地优化时间复杂度，在很多算法中都有应用，其中最常见的就是**ST 表**以及**LCA（树上最近公共祖先）**了。

#### Example I

> 在你面前的桌子上，摆着无数个重量为任意整数的胡萝卜；
> 接着告诉你一个数字`n`，问你要怎么挑选，使得你选出的胡萝卜能够表示出`[1,n]`区间内的所有整数重量？

> 读完题后我们马上就能想到一种选法，那就是选`n`个重量为`1`的胡萝卜，这样就能通过加减表示出`[1,n]`内的所有重量了。
> 但问题是……这样挑选的胡萝卜是不是太多了点？
> 我们很快就能发现，只需要选择重量为`1,2,4,8,16`的胡萝卜，就能表示`[1,31]`内的所有重量……只需要选择重量`1,2,4...2^i`的胡萝卜，就能表示`[1,2^(i+1)-1]`内的所有重量……
> 也就是说， 对于给定的数字`n`，根本不需要选那么多胡萝卜，只需要 `log2(n)`（[]为向下取整）个胡萝卜就够啦！
> 由此引例我们得出一个结论：**只需要`log2(n)`的预处理，就能表示出`[1,n]`区间内的所有情况。**

#### Example II

> 有一个环状的操场，操场被分割为`[`1,n]`个小块，每个小块上写着一个数字。有一只小白兔站在操场的起点，它每次可以跳`k`个小块，然后拿走等同于它所站小块上数字数量的胡萝卜，问它跳`m`次，总共可以拿到几个胡萝卜？如果能够算出来的话，小白兔就能把所有的胡萝卜都带回家吃啦！`1<=k<=n<=10^6, 1<=m<=10^18`

> 可以让小白兔跳 m 次，一次一次跳，这样白兔会累死。
> 只需要记录跳`1,2,4,8,16...2log2(m)`次分别能够拿到的胡萝卜数，就能得到跳[1,m]区间内任何一个数字能拿到的胡萝卜数。
> 这样子，即便`m=10^18`也只需要预处理 64 以内的数据就可以了。
> `to[x][i]`代表从起点`x`跳`2^i`步后到达的小块编号，`carrot[x][i]`表示从起点`x`跳`2^i`步后能拿到的胡萝卜数。

#### 树上倍增`LCA`

> 适用的场景，求**最近公共祖先**，求出 1, 2, 4, 8, 16, ... 2^k 的祖先，然后求出两个节点的最近公共祖先。这样的话，就可以将求最近公共祖先的复杂度降低到 `O(logn)`。对于每个数都可以使用二进制的思想，将其分解成 2^k 的和，然后求出每个 2^k 的祖先，然后求出两个节点的最近公共祖先。可以先预处理出每个节点的 2^k 的祖先，然后求出两个节点的最近公共祖先。比如，`14 = 2^3 + 2^2 + 2^1`，那么就可以求出 `14` 的 `2^3` 的祖先，`2^2` 的祖先，`2^1` 的祖先，这样就可以快速算出目标点。

#### 代码模板

[Q1483] Kth Ancestor of a Tree Node

> 最近公共祖先模板题

```python
class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        m = n.bit_length() - 1
        # pa[x][i] 表示x的第2^i个祖先
        # pa[x][0] = parent[x] 跳2^0
        # pa[x][1] = pa[pa[x][0]][0] 跳2^1
        # pa[x][i+1] = pa[pa[x][i]][i]
        pa = [[p] + [-1] * m for p in parent]
        for i in range(m):
            for x in range(n):
                p = pa[x][i]
                if p != -1:
                    pa[x][i + 1] = pa[p][i]
        # self.depth = depth
        self.pa = pa


    def getKthAncestor(self, node: int, k: int) -> int:
        for i in range(k.bit_length()):
            if (k >> i) & 1:
                node = self.pa[node][i]
                if node == -1:
                    return -1
        return node
```

#### 相关问题

[Q2836] Maximize Value of Function in a Ball Passing Game

> 传球的路径会构成一个基环树(环+树)，枚举每个点作为起点，求出路径上所有的点的和，然后求出最大值。这样的时间复杂度是`O(n*k)`,这样走太慢了。可以考虑使用倍增，每个正整数都可以拆分出二进制表示，可以走 2^i 之后的节点。并且还要预处理从`x`的父节点，到`x`的第`2^i`个祖先的节点路径上编号之和。

```python
class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
        n = len(receiver)
        m = k.bit_length() - 1
        pa = [[(p, p)] + [None] * m for p in receiver]
        for i in range(m):
            for x in range(n):
                p, s = pa[x][i]
                pp, ss = pa[p][i]
                pa[x][i + 1] = (pp, s + ss)

        # 枚举起点
        ans = 0
        for i in range(n):
            x = sum = i
            for j in range(m + 1):
                if k >> j & 1:
                    x, s = pa[x][j]
                    sum += s
            ans = max(ans, sum)
        return ans
```

[//]: #
[Q2836]: https://leetcode.com/problems/maximize-value-of-function-in-a-ball-passing-game/
[Q1483]: https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/
