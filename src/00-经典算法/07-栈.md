### 栈

**06/30/2023**

#### 核心思想

> 适用的场景，栈用来维护最近的两个元素之间的操作，如果发现需要维护的是两个最近元素之间的操作，可以考虑使用栈。
>
> -   括号匹配模型
> -   表达式模型

#### 代码模板

> Python 通常使用列表来模拟栈

#### 相关问题

[Q735] - 行星碰撞 经典

> 开始向左的行星，不会和任何行星相撞。
> 向右的行星会与向左的行星相撞，就分类讨论。x >= y, x < y
> 栈里的行星都是向右运行。我们维护的就是**当前元素和最后一个元素之间的操作**，栈可以维护这样的操作。
> 我们用一个栈来维护向右运行的行星。

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for size in asteroids:
            if size > 0: # 向右方向
                stack.append(size)
                continue
            while stack and stack[-1] > 0: # 栈 LLL...RRR
                top = stack[-1]
                if -size >= top:
                    stack.pop()
                if -size <= top:
                    break
            else: # while 中没有break，表示没有向右的行星
                stack.append(size)
        return stack
```

[Q2751] - 机器人碰撞

> 思考第一个机器人如何和其它机器人相撞
> 开始的机器人向左运行，不会相撞
> 机器人向右运行，遇到向左的机器人，相撞，分 3 类讨论，x > y, x =y, x < y
> 代码实现，对于向右的机器人加入栈中，向左的机器人，放入数组，最后合并。

-   python

```python
class Solution:
    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        n = len(positions)
        a = sorted(zip(range(n), positions, healths, directions), key=lambda p: p[1])
        to_left = [] # 向左
        st = [] # 向右
        for i, _, h, d in a:
            if d == 'R': # 向右，存入栈中
                st.append([i, h])
                continue
            # 当机器人向左，与栈中向右的机器人相撞
            while st:
                top = st[-1]
                # 分3类情况讨论，栈顶的健康程度x, 与栈顶相撞的机器人的健康程度y
                # 1. x > y
                if top[1] > h:
                    top[1] -= 1
                    break
                # 2. x == y
                if top[1] == h:
                    st.pop()
                    break
                # 3. x < y
                h -= 1
                st.pop()
            else: # 这样写会少用一个flag
                # while中没有break，栈中没有机器人，表示向右的都被向左的撞掉了，就加入向左的地方
                to_left.append([i, h])
        to_left += st # 合并剩余的机器人
        to_left.sort(key=lambda p: p[0])
        return [h for _, h in to_left]
```

### 单调栈

#### 核心思想

> 及时去掉无用的数据，保证栈中数据有序。线性结构，可以从左向右遍历，也可以从右向左遍历。两种遍历方式，存在栈中的数据是不一样的。
> **如果题目需要维护的信息是上一个更大(小)的元素**

#### 代码模板

> 栈中存在的一般是下标，便于快速找到元素。下标也会维护一些信息，比如距离。

```python
st = []
for i, x in enumerate(nums):
    while st and st[-1] (>, >=, <, <=) x:
        # 维护一些信息
        st.pop()
    st.append(i) # 存下标是因为维护信息需要用到下标的信息，比如计算距离
```

#### 相关问题

[Q739] - Daily Temperatures

> 找到下一个比当前元素更大的元素。可以从右向左遍历，也可以从左向右遍历。
>
> 1. 从右向左遍历，栈中的元素是递减的，存的是下一个更大的元素。
> 2. 从左向右遍历，栈中的元素是递增的，栈中存的是没有找到下一个更大元素的元素。

方法 I: 从右向左遍历

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans = [0] * n
        st = []
        for i in range(n - 1, -1, -1):
            t = temperatures[i]
            while st and temperatures[st[-1]] <= t:
                st.pop()
            if st:
                ans[i] = st[-1] - i
            st.append(i)
        return ans
```

方法 II: 从左向右遍历

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans = [0] * n
        st = []

        for i, t in enumerate(temperatures):
            while st and temperatures[st[-1]] < t:
                j = st.pop()
                ans[j] = i - j
            st.append(i)
        return ans
```

[Q42] - Trapping Rain Water

> 前后缀分解，竖着计算，每个位置有个桶，桶的高度是左右两边最高的高度的最小值，减去当前位置的高度，就是当前位置的水量。
> 单调栈，横着计算。从左向右遍历，找到下一个比栈顶元素大的数，就可以更新答案，需要`3`个变量，`left`，`right`，`height`。`left`和`right`是下标，`height`是高度。填坑。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        st = []
        for i, h in enumerate(height):
            while st and h >= height[st[-1]]:
                bottom_h = height[st.pop()]
                if not st: # st is empty 需要左边的柱子高度
                    break
                left = st[-1]
                dh = min(height[left], h) - bottom_h
                ans += dh * (i - left - 1)
            st.append(i)
        return ans
```

[Q1475] - Final Prices With a Special Discount in a Shop

> 找到右边第一个比当前数小的数，可以使用单调栈维护一个递增的单调栈，从左向右遍历，栈中存的是下标，维护的是下一个更小的数。

```python
class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        # 找到第一个比它小的数
        n = len(prices)
        ans = prices.copy()
        st = []
        for i, x in enumerate(prices):
            while st and prices[st[-1]] >= x:
                j = st.pop()
                ans[j] = prices[j] - x # 更新答案
            st.append(i)
            # ans[i] = x
        return ans
```

[Q901] - Online Stock Span

> 找到上一个比当前数大的数，可以使用单调栈维护一个递减的单调栈，从左向右遍历，栈中存的是下标，维护的是上一个更大的数。
> 但是数据是流式的，使用元组记录下标和值，维护的是上一个更大的数的下标和值。

```python
class StockSpanner:

    def __init__(self):
        self.stack = [(-1, inf)]
        self.cur_day = -1

    def next(self, price: int) -> int:
        while price >= self.stack[-1][1]:
            self.stack.pop()
        self.cur_day += 1
        self.stack.append((self.cur_day, price))
        return self.cur_day - self.stack[-2][0]
```

[Q1019] - Next Greater Node In Linked List

> 找到右边第一个比当前数大的数，可以使用单调栈维护一个递增的单调栈，从左向右遍历，栈中存的是下标，维护的是下一个更大的数。栈里存的元素都是没有找到下一个更大的数的元素。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:
        a = []
        p = head
        while p:
            a.append(p.val)
            p = p.next
        ans = [0] * len(a)
        st = []
        for i, x in enumerate(a):
            while st and a[st[-1]] < x:
                j = st.pop()
                ans[j] = x
            st.append(i)
        return ans

```

[Q84] - Largest Rectangle in Histogram

> 计算矩形的面积，`w * h`，`h`是每个矩形的高度，`w`是找到左右边界，也就是找到左右两边第一个比当前数小的数的下标。`right - left - 1`。使用单调栈可以找到左右两边第一个比当前数小的数的下标。

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left, right = [0] * n, [0] * n

        st = []
        for i, x in enumerate(heights):
            while st and heights[st[-1]] >= x:
                st.pop()
            if not st:
                left[i] = -1
            else:
                left[i] = st[-1]
            st.append(i)

        st = []
        for i in range(n - 1, -1, -1):
            while st and heights[st[-1]] >= heights[i]:
                st.pop()
            if not st:
                right[i] = n
            else:
                right[i] = st[-1]
            st.append(i)

        ans = 0
        for i in range(n):
            ans = max(ans, heights[i] * (right[i] - left[i] - 1))
        return ans
```

[//]: #
[Q735]: https://leetcode.cn/problems/asteroid-collision/
[Q2751]: https://leetcode.cn/problems/robot-collisions/solutions/2319664/zhan-mo-ni-by-endlesscheng-fu26/
[Q739]: https://leetcode-cn.com/problems/daily-temperatures/
[Q42]: https://leetcode-cn.com/problems/trapping-rain-water/
[Q1475]: https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/
[Q901]: https://leetcode-cn.com/problems/online-stock-span/
[Q1019]: https://leetcode-cn.com/problems/next-greater-node-in-linked-list/
[Q84]: https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
