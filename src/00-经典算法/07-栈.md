### 栈

**06/30/2023**

#### 核心思想

> 适用的场景，栈用来维护最近的两个元素之间的操作，如果发现需要维护的是两个**最近元素之间的操作**，可以考虑使用栈。
>
> -   括号匹配模型
> -   表达式模型

#### 代码模板

> Python 通常使用列表来模拟栈

#### 相关问题

[Q735] - 行星碰撞 经典

> 开始向左的行星，不会和任何行星相撞。
> 向右的行星会与向左的行星相撞，就分类讨论。x >= y, x < y
> 栈里的行星都是向右运行。我们维护的就是**当前元素和最后一个元素之间的操作**，栈可以维护这样的操作。
> 我们用一个栈来维护向右运行的行星。

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for size in asteroids:
            if size > 0: # 向右方向
                stack.append(size)
                continue
            while stack and stack[-1] > 0: # 栈 LLL...RRR
                top = stack[-1]
                if -size >= top:
                    stack.pop()
                if -size <= top:
                    break
            else: # while 中没有break，表示没有向右的行星
                stack.append(size)
        return stack
```

[Q2751] - 机器人碰撞

> 思考第一个机器人如何和其它机器人相撞
> 开始的机器人向左运行，不会相撞
> 机器人向右运行，遇到向左的机器人，相撞，分 3 类讨论，x > y, x =y, x < y
> 代码实现，对于向右的机器人加入栈中，向左的机器人，放入数组，最后合并。

-   python

```python
class Solution:
    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        n = len(positions)
        a = sorted(zip(range(n), positions, healths, directions), key=lambda p: p[1])
        to_left = [] # 向左
        st = [] # 向右
        for i, _, h, d in a:
            if d == 'R': # 向右，存入栈中
                st.append([i, h])
                continue
            # 当机器人向左，与栈中向右的机器人相撞
            while st:
                top = st[-1]
                # 分3类情况讨论，栈顶的健康程度x, 与栈顶相撞的机器人的健康程度y
                # 1. x > y
                if top[1] > h:
                    top[1] -= 1
                    break
                # 2. x == y
                if top[1] == h:
                    st.pop()
                    break
                # 3. x < y
                h -= 1
                st.pop()
            else: # 这样写会少用一个flag
                # while中没有break，栈中没有机器人，表示向右的都被向左的撞掉了，就加入向左的地方
                to_left.append([i, h])
        to_left += st # 合并剩余的机器人
        to_left.sort(key=lambda p: p[0])
        return [h for _, h in to_left]
```

### 单调栈

#### 核心思想

> 单调栈，维护一个单调递增或者单调递减的栈，栈顶元素是最小或者最大的元素。也是**最近两个元素之间的操作**。只不过栈内元素单调递增或递减。

#### 代码模板

```python
st = []
for i, x in enumerate(nums):
    while st and st[-1] (>, >=, <, <=) x:
        # 维护一些信息
        st.pop()
    st.append(i) # 存下标是因为维护信息需要用到下标的信息，比如计算距离
```

#### 相关问题

[Q496] Next Greater Element I (模板题)

> 经典的单调栈应用，找到右边第一个比当前元素大的数。

```python

```

[Q2866] Beautiful Towers II

> 枚举每个元素作为最高点，左右两边都是独立的，前后缀分解。维护后缀是个递减序列，当前元素如果小于栈顶元素，就得更新成栈顶元素，同时将栈顶元素全部弹出，维护元素和，可以使用先减后加的方式，减去弹出的元素，加上当前元素。前缀同理，维护一个递增序列。使用一个单调栈来完成维护。

```python
class Solution:
    def maximumSumOfHeights(self, nums: List[int]) -> int:
        n = len(nums)
        suf = [0] * (n + 1)
        st = [n]
        s = 0
        for i in range(n - 1, -1, -1):
            x = nums[i]
            while len(st) > 1 and x <= nums[st[-1]]:
                j = st.pop()
                s -= nums[j] * (st[-1] - j) # 先将原来的数字减掉
            s += x * (st[-1] - i)
            suf[i] = s
            st.append(i) # 因为要计算长度，存下标

        ans = s
        st = [-1]
        pre = 0 # 上升子序列的和
        for i, x in enumerate(nums):
            while len(st) > 1 and x <= nums[st[-1]]:
                j = st.pop()
                pre -= nums[j] * (j - st[-1])
            pre += x * (i - st[-1]) # 从st[-1] + 1 到 i 都是 x
            ans = max(ans, pre + suf[i + 1])
            st.append(i)
        return ans
```

```C++
using ll = long long;

class Solution {
public:
    long long maximumSumOfHeights(vector<int>& a) {
        int n = a.size();
        vector<ll> suf(n + 1);
        stack<int> st;
        st.push(n);
        ll s{0};
        for (int i = n - 1; i >= 0; -- i) {
            int x = a[i];
            while (st.size() > 1 && x <= a[st.top()]) {
                int j = st.top();
                st.pop();
                s -= (ll) a[j] * (st.top() - j); // remove sum of a[j]
            }
            s += (ll) x * (st.top() - i);
            suf[i] = s;
            st.push(i);
        }

        ll ans = s;
        st = stack<int>();
        st.push(-1);
        ll pre{0};
        for (int i = 0; i < n;  ++ i) {
            int x = a[i];
            while (st.size() > 1 && x <= a[st.top()]) {
                int j = st.top();
                st.pop();
                pre -= (ll) a[j] * (j - st.top());
            }
            pre += (ll) x * (i - st.top());
            ans = max(ans, pre + suf[i + 1]);
            st.push(i);
        }
        return ans;
    }
};
```

Follow-up Question
[Q1671] Minimum Number of Removals to Make Mountain Array

>

[//]: #
[Q735]: https://leetcode.cn/problems/asteroid-collision/
[Q2751]: https://leetcode.cn/problems/robot-collisions/solutions/2319664/zhan-mo-ni-by-endlesscheng-fu26/
[Q496]: https://leetcode-cn.com/problems/next-greater-element-i/
[Q2866]: https://leetcode.com/problems/beautiful-towers-ii/
[Q1671]: https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/description/
