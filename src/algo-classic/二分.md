### Binary Search

**06/29/2023**

#### 核心思想
> 适用的场景，主要在线性的数据结构上，利用数据的性质。可以将数据分成两段，具有**二段性**。找到一个性质，就是解决这类问题的关键。
> 二分是常用的算法，如果题目中出现关键字，最大的最小，最小的最大，之类的词语，使用二分算法的可能性非常大。
> 如果没有思路的时候，也可以试试二分。观察数据范围也是非常重要的提示。

#### 代码模板 - lower_bound模型
> 问题，求解 >= target的第一个整数的位置
> 定义二段性性质，因为是有序序列，定义 red: < target, blue: >= target
> 代码实现分为3种，之所以有三种，完全是根据初始的左右边界开闭来区分的。
> 注意四个要素，
> 1. 根据开闭区间，初始化边界
> 2. 循环结束条件，也是区间内没有任何数为终止条件
> 3. 如何更新区间的边界
> 4. 答案
- 闭区间写法[left, right]
```python
def lower_bound(nums, target):
    # 闭区间[0, n-1]
    # 初始化边界
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1 # 根据二段性，更新边界
        else:
            right = mid - 1
    return left 
```

- 左闭右开写法[left, right)
```python
def lower_bound(nums, target):
    # 闭区间[0, n)
    left, right = 0, len(nums)
    while left < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left 
```

- 左开右开写法(left, right)
```python
def lower_bound(nums, target):
    # 闭区间(-1, n)
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid
        else:
            right = mid
    return right
```

#### 相关问题

[Q34] - 在排序数组中查找元素的第一个和最后一个位置
 - 经典lower_bound模型的应用。寻找 >= x, <= x的边界。求边界转化成lower_bound的方法
```python
  > x => lower_bound(x + 1)
  < x => lower_bound(x) - 1
  <= x => (> x) - 1 => lower_bound(x + 1) - 1
```
- python

```python
def lower_bound_1(nums, target):
    # 闭区间[0, n-1]
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left 

def lower_bound_2(nums, target):
    # 闭区间[0, n)
    left, right = 0, len(nums)
    while left < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left 

def lower_bound_3(nums, target):
    # 闭区间(-1, n)
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid
        else:
            right = mid
    return right

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # 方法I, 手写binary search
        start = lower_bound_3(nums, target)
        # 对于数组问题，首先考虑越界问题，所以先判断start == n
        if start == len(nums) or nums[start] != target: 
            return [-1, -1]
        end = lower_bound_1(nums, target + 1) - 1 
        return [start, end]

# 方法直接使用python的库函数
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # method II bisect_left, bisect_right
        n = len(nums)
        start = bisect_left(nums, target)
        if start == n or nums[start] != target:
            return [-1, -1]
        end = bisect_right(nums, target) - 1
        return [start, end]
```

[Q153] - 寻找旋转排序数组中的最小值
> - 关键字，有序数组，考虑使用二分。
> - 寻找并定义二段性的性质，二分的数字和最后一个数相比，red: 在最小数的左侧， blue:在最小数和最小数的右侧。
> - 选3种二分的一个方法实现代码。
- 开区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 查询的区间是[0, n - 1]
        # 使用开区间写法，定义初始左右边界
        left, right = -1, len(nums)
        while left + 1 < right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]: # blue区间
                right = mid 
            else:
                left = mid # red区间
        
        return nums[right]
```
- 闭区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 初始化边界，闭区间
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]:
                right = mid - 1
            else:
                left = mid + 1
        
        return nums[left]
```

- 左闭右开区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 左闭右开区间初始化边界
        left, right = 0, len(nums)
        while left < right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]:
                right = mid
            else:
                left = mid + 1
        
        return nums[left]
```

[Q33] - 搜索旋转排序数组
> - 关键字，有序序列。可以考虑二分。
> - 寻找并定义二段性的性质
>  - blue: 数字在target和target的右边
>  - red: 数字在target的左边
> - target和二分的位置都会在左右两边，讨论的情况会比较多
> 遇到两个变量的通常的原则是，固定二分的位置，然后讨论它在target的左边或右边进行红蓝二段染色
> 在实现的时候，将二段性判断的复杂逻辑写成一个函数。

- 使用开区间写法
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # blue: numbers are on the right side of target including target
        def is_blue(i):
            end = nums[-1]
            if nums[i] > end:
                return target > end and nums[i] >= target 
            else:
                return target > end or nums[i] >= target

        left, right = -1, len(nums) # [0, n-1]
        while left + 1 < right:
            mid = left + right >> 1
            if is_blue(mid):
                right = mid 
            else:
                left = mid 
        return right if nums[right] == target else -1
```

[Q2563] - 统计公平数对的数目
> lower <= a + b <= upper, 这里包含2个数。
> - 经典技巧，固定一个数字。枚举另外一个数的取值范围。
> 枚举a，b的范围 lower - a <= b <= upper - a
> - 求数对，原来的次序无关，所以可以进行排序。
> 通过前两步的转化，就转化成经典的lower_bound模型，<= x, >= x
> 数对的数目 = > x - <= x

```python
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        ans = 0
        for i, x in enumerate(nums):
            r = bisect_right(nums, upper - x, 0, i)
            l = bisect_left(nums, lower - x, 0, i)
            ans += r - l 
        return ans 
```

#### 参考资源
- Python [bisect]

[Q] - 小数二分


### Binary Search on Answer Space

#### 核心思想
> - 答案的范围是可以确认的。
> - 猜一个答案x, 根据题目的定义的操作, 可否完成操作, 如果可以，说明 >= x的答案都可以。如果不可以，说明 < x都不可以。这样就可以将答案的空间分成两段。可以使用二分。

#### 代码模板
> - check函数
> - 二分模板
```python
def check(mid):
    # 根据题目要求进行模拟，返回true or false
    pass

left, right = answser_space
binary search
```

#### 相关题目

[Q2439] 最小化数组中的最大值
> - 关键字，最小化最大值 => 二分答案
> - 猜一个最大值，模拟一下 O(n log max(nums))

```python
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        # 模拟求最大值的过程
        def check(limit):
            a = nums[:]
            for i in range(len(a)-1, 0, -1):
                x = a[i]
                if x > limit:
                    a[i - 1] += x - limit 
            return a[0] <= limit
        
        left, right = -1, max(nums) + 1 #[0, mx]
        while left + 1 < right:
            mid = left + right >> 1
            if check(mid):
                right = mid 
            else:
                left = mid 
        return right 
        
        # # 方法II 利用python3.10的新特性
        # return bisect_left(range(max(nums)), True, key=check)
```

[Q410] 分割数组的最大值
> 关键字 最大值最小 => 二分答案
> 确定答案空间，最小和最大值
> 判定函数, 判定一个答案x, 如果满足条件, >= x的都会满足, 就可以去掉, 也就是将答案的空间的上界缩小
> 利用二分模板找到答案

- python
```python
class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        def check(mid):
            cnt, s = 1, 0
            for x in nums:
                if s + x <= mid:
                    s += x
                else:
                    cnt += 1
                    s = x 
            return cnt <= k # 思考一下，为什么不是cnt==k
        
        # answer space
        left, right = max(nums) - 1, sum(nums)
        while left + 1 < right:
            mid = left + right >> 1 
            if check(mid):
                right = mid 
            else:
                left = mid 
        return right
```

[Q1011] 在D天内送达包裹的能力
> 关键字，最低运载能力。
> 本质是将数组分成若干子数组，使得若干个子数组的总和最小。
> 和410的模型一样的。

- python
```python
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        def check(mid):
            cnt, s = 1, 0
            for x in weights:
                if s + x <= mid:
                    s += x
                else:
                    s = x
                    cnt += 1
            return cnt <= days 
        
        left, right = max(weights) - 1, sum(weights) + 1
        while left + 1 < right:
            mid = left + right >> 1
            if check(mid):
                right = mid 
            else:
                left = mid 
        return right 
```

- 经典二分答案

[Q875] 爱吃香蕉的珂珂
> 关键字，最小。尝试一下能否二分。
> 思考是否有单调性或者二段性，如果可以在速度k吃完，速度k+1, k+2...都可以吃完
> 如果速度k无法吃完，速度k-1, k-2, k-3都无法吃完
> 具有二段性。
> check(x)，sum(t) <= h

```python
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        check = lambda x: sum(ceil(pile / x) for pile in piles) <= h
     
        left, right = 0, max(piles) + 1
        while left + 1 < right:
            mid = left + right >> 1
            if check(mid):
                right = mid 
            else:
                left = mid 
        return right 
```

[Q2187] 完成旅途的最少时间
> 关键字，最小。尝试一下能否二分。
> 思考是否有单调性或者二段性，如果可以在t时间可以完成totalTrips，速度t+1, t+2...都可以完成
> 如果时间t无法完成，时间t-1, t-2, t-3都无法完成
> 具有二段性。
> check(x)，sum(x // t) >= totalTrips

```python
class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        check = lambda x: sum(x // t for t in time) >= totalTrips
        left, right = 0, totalTrips * max(time) + 1
        while left + 1 < right:
            mid = left + right >> 1 
            if check(mid):
                right = mid 
            else:
                left = mid 
        return right

# 方法II - 利用bisect_left
class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        check = lambda x: sum(x // t for t in time)
        return bisect_left(range(totalTrips * max(time) + 1), totalTrips, key=check)
```

[Q2226] 每个小孩最多能分到多少糖果
> 关键字，最大。尝试一下能否二分。
> 思考是否有单调性或者二段性，如果可以x个糖果，x-1, x-2都可以完成
> 如果x个糖果无法完成，x+1, x+2, x+3都无法完成
> 具有二段性。
> check(x)
```python
```

[Q1482] 制作 m 束花所需的最少天数
>
- python
```python
```



[Q475] 取暖器
> 

- python
```python
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()

        def check(x):
            n, m = len(houses), len(heaters)
            # 使用双指针，找到离每个房子最近的heater，然后看能否覆盖它
            j = 0
            for i, h in enumerate(houses):
                # 找到离每个房子最近的heater
                while j < m and h > heaters[j] + x:
                    j += 1
                if j >= m or heaters[j] - x > h or heaters[j] + x < h:
                    return False  
            return True

        
        left, right = -1, 10**9
        while left + 1 < right:
            mid = left + right >> 1
            if check(mid):
                right = mid 
            else:
                left = mid 
        return right
```

[//]: # 
   [Q34]: <https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/>

   [Q153]: <https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/>

   [Q33]: <https://leetcode.cn/problems/search-in-rotated-sorted-array/>

   [Q2563]: <https://leetcode.cn/problems/count-the-number-of-fair-pairs/>

   [bisect]: <https://docs.python.org/3/library/bisect.html>

   [Q2439]: <https://leetcode.cn/problems/minimize-maximum-of-array/>

   [Q410]: <https://leetcode.cn/problems/split-array-largest-sum/description/>

   [Q1011]: <https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/>

   [Q475]: <https://leetcode.cn/problems/heaters/>
   
   [Q2594]: <https://leetcode.cn/problems/minimum-time-to-repair-cars/>

   [Q1482]: <https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/description/>

   [Q875]: <https://leetcode.cn/problems/koko-eating-bananas/>

   [2187]: <https://leetcode.cn/problems/minimum-time-to-complete-trips/>

   [2226]: <https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/>
