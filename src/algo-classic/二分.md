### Binary Search

**06/29/2023**

#### 核心思想
> 适用的场景，主要在线性的数据结构上，利用数据的性质。可以将数据分成两段，具有**二段性**。找到一个性质，就是解决这类问题的关键。
> 二分是常用的算法，如果题目中出现关键字，最大的最小，最小的最大，之类的词语，使用二分算法的可能性非常大。
> 如果没有思路的时候，也可以试试二分。观察数据范围也是非常重要的提示。

#### 代码模板 - lower_bound模型
> 问题，求解 >= target的第一个整数的位置
> 定义二段性性质，因为是有序序列，定义 red: < target, blue: >= target
> 代码实现分为3种，之所以有三种，完全是根据初始的左右边界开闭来区分的。
> 注意四个要素，
> 1. 根据开闭区间，初始化边界
> 2. 循环结束条件，也是区间内没有任何数为终止条件
> 3. 如何更新区间的边界
> 4. 答案
- 闭区间写法[left, right]
```python
def lower_bound(nums, target):
    # 闭区间[0, n-1]
    # 初始化边界
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1 # 根据二段性，更新边界
        else:
            right = mid - 1
    return left 
```

- 左闭右开写法[left, right)
```python
def lower_bound(nums, target):
    # 闭区间[0, n)
    left, right = 0, len(nums)
    while left < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left 
```

- 左开右开写法(left, right)
```python
def lower_bound(nums, target):
    # 闭区间(-1, n)
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid
        else:
            right = mid
    return right
```

#### 相关问题

[Q34] - 在排序数组中查找元素的第一个和最后一个位置
 - 经典lower_bound模型的应用。寻找 >= x, <= x的边界。求边界转化成lower_bound的方法
```python
  > x => lower_bound(x + 1)
  < x => lower_bound(x) - 1
  <= x => (> x) - 1 => lower_bound(x + 1) - 1
```
- python

```python
def lower_bound_1(nums, target):
    # 闭区间[0, n-1]
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left 

def lower_bound_2(nums, target):
    # 闭区间[0, n)
    left, right = 0, len(nums)
    while left < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left 

def lower_bound_3(nums, target):
    # 闭区间(-1, n)
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid
        else:
            right = mid
    return right

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # 方法I, 手写binary search
        start = lower_bound_3(nums, target)
        # 对于数组问题，首先考虑越界问题，所以先判断start == n
        if start == len(nums) or nums[start] != target: 
            return [-1, -1]
        end = lower_bound_1(nums, target + 1) - 1 
        return [start, end]

# 方法直接使用python的库函数
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # method II bisect_left, bisect_right
        n = len(nums)
        start = bisect_left(nums, target)
        if start == n or nums[start] != target:
            return [-1, -1]
        end = bisect_right(nums, target) - 1
        return [start, end]
```

[Q153] - 寻找旋转排序数组中的最小值
> - 关键字，有序数组，考虑使用二分。
> - 寻找并定义二段性的性质，二分的数字和最后一个数相比，red: 在最小数的左侧， blue:在最小数和最小数的右侧。
> - 选3种二分的一个方法实现代码。
- 开区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 查询的区间是[0, n - 1]
        # 使用开区间写法，定义初始左右边界
        left, right = -1, len(nums)
        while left + 1 < right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]: # blue区间
                right = mid 
            else:
                left = mid # red区间
        
        return nums[right]
```
- 闭区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 初始化边界，闭区间
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]:
                right = mid - 1
            else:
                left = mid + 1
        
        return nums[left]
```

- 左闭右开区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 左闭右开区间初始化边界
        left, right = 0, len(nums)
        while left < right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]:
                right = mid
            else:
                left = mid + 1
        
        return nums[left]
```

[Q] - 小数二分

[//]: # 
   [Q34]: <https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/>

   [Q153]: <https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/>