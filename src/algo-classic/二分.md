### Binary Search

**06/29/2023**

#### 核心思想
> 适用的场景，主要在线性的数据结构上，利用数据的性质。可以将数据分成两段，具有**二段性**。找到一个性质，就是解决这类问题的关键。
> 二分是常用的算法，如果题目中出现关键字，最大的最小，最小的最大，之类的词语，使用二分算法的可能性非常大。
> 如果没有思路的时候，也可以试试二分。观察数据范围也是非常重要的提示。

#### 代码模板 - lower_bound模型
> 问题，求解 >= target的第一个整数的位置
> 定义二段性性质，因为是有序序列，定义 red: < target, blue: >= target
> 代码实现分为3种，之所以有三种，完全是根据初始的左右边界开闭来区分的。
> 注意四个要素，
> 1. 根据开闭区间，初始化边界
> 2. 循环结束条件，也是区间内没有任何数为终止条件
> 3. 如何更新区间的边界
> 4. 答案
- 闭区间写法[left, right]
```python
def lower_bound(nums, target):
    # 闭区间[0, n-1]
    # 初始化边界
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1 # 根据二段性，更新边界
        else:
            right = mid - 1
    return left 
```

- 左闭右开写法[left, right)
```python
def lower_bound(nums, target):
    # 闭区间[0, n)
    left, right = 0, len(nums)
    while left < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left 
```

- 左开右开写法(left, right)
```python
def lower_bound(nums, target):
    # 闭区间(-1, n)
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid
        else:
            right = mid
    return right
```

#### 相关问题

[Q34] - 在排序数组中查找元素的第一个和最后一个位置
 - 经典lower_bound模型的应用。寻找 >= x, <= x的边界。求边界转化成lower_bound的方法
```python
  > x => lower_bound(x + 1)
  < x => lower_bound(x) - 1
  <= x => (> x) - 1 => lower_bound(x + 1) - 1
```
- python

```python
def lower_bound_1(nums, target):
    # 闭区间[0, n-1]
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left 

def lower_bound_2(nums, target):
    # 闭区间[0, n)
    left, right = 0, len(nums)
    while left < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left 

def lower_bound_3(nums, target):
    # 闭区间(-1, n)
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + right >> 1 
        if nums[mid] < target:
            left = mid
        else:
            right = mid
    return right

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # 方法I, 手写binary search
        start = lower_bound_3(nums, target)
        # 对于数组问题，首先考虑越界问题，所以先判断start == n
        if start == len(nums) or nums[start] != target: 
            return [-1, -1]
        end = lower_bound_1(nums, target + 1) - 1 
        return [start, end]

# 方法直接使用python的库函数
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # method II bisect_left, bisect_right
        n = len(nums)
        start = bisect_left(nums, target)
        if start == n or nums[start] != target:
            return [-1, -1]
        end = bisect_right(nums, target) - 1
        return [start, end]
```

[Q153] - 寻找旋转排序数组中的最小值
> - 关键字，有序数组，考虑使用二分。
> - 寻找并定义二段性的性质，二分的数字和最后一个数相比，red: 在最小数的左侧， blue:在最小数和最小数的右侧。
> - 选3种二分的一个方法实现代码。
- 开区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 查询的区间是[0, n - 1]
        # 使用开区间写法，定义初始左右边界
        left, right = -1, len(nums)
        while left + 1 < right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]: # blue区间
                right = mid 
            else:
                left = mid # red区间
        
        return nums[right]
```
- 闭区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 初始化边界，闭区间
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]:
                right = mid - 1
            else:
                left = mid + 1
        
        return nums[left]
```

- 左闭右开区间写法
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 左闭右开区间初始化边界
        left, right = 0, len(nums)
        while left < right:
            mid = left + right >> 1
            if nums[mid] <= nums[-1]:
                right = mid
            else:
                left = mid + 1
        
        return nums[left]
```

[Q33] - 搜索旋转排序数组
> - 关键字，有序序列。可以考虑二分。
> - 寻找并定义二段性的性质
>  - blue: 数字在target和target的右边
>  - red: 数字在target的左边
> - target和二分的位置都会在左右两边，讨论的情况会比较多
> 遇到两个变量的通常的原则是，固定二分的位置，然后讨论它在target的左边或右边进行红蓝二段染色
> 在实现的时候，将二段性判断的复杂逻辑写成一个函数。

- 使用开区间写法
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # blue: numbers are on the right side of target including target
        def is_blue(i):
            end = nums[-1]
            if nums[i] > end:
                return target > end and nums[i] >= target 
            else:
                return target > end or nums[i] >= target

        left, right = -1, len(nums) # [0, n-1]
        while left + 1 < right:
            mid = left + right >> 1
            if is_blue(mid):
                right = mid 
            else:
                left = mid 
        return right if nums[right] == target else -1
```

[Q2563] - 统计公平数对的数目
> lower <= a + b <= upper, 这里包含2个数。
> - 经典技巧，固定一个数字。枚举另外一个数的取值范围。
> 枚举a，b的范围 lower - a <= b <= upper - a
> - 求数对，原来的次序无关，所以可以进行排序。
> 通过前两步的转化，就转化成经典的lower_bound模型，<= x, >= x
> 数对的数目 = > x - <= x

```python
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        ans = 0
        for i, x in enumerate(nums):
            r = bisect_right(nums, upper - x, 0, i)
            l = bisect_left(nums, lower - x, 0, i)
            ans += r - l 
        return ans 
```

[Q] - 小数二分

[//]: # 
   [Q34]: <https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/>

   [Q153]: <https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/>

   [Q33]: <https://leetcode.cn/problems/search-in-rotated-sorted-array/>

   [Q2563]: <https://leetcode.cn/problems/count-the-number-of-fair-pairs/>
