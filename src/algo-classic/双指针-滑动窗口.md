### 双指针

**07/02/2023**

#### 核心思想
> 本质是数据所有维护的信息具有**单调性**，可以枚举右端点，维护信息，缩小左端点来维护满足条件的信息。不断地更新答案。
> 适用场景，主要在线性的数据结构上。是一种优化技巧，可以降低一个维度。特别是关于**子数组**相关的问题，因为会维护子数组的起点和终点。
> 前提，维护的性质具有单调性，枚举left，拓展right，来维护子数组的信息。右指针是不会回头的。

#### 代码模板
> - 枚举右端点，收缩左端点，维护信息。而不是枚举左端点，拓展右端点，这样需要判断右端点越界问题。代码实现容易。
> - 右端点无脑滑动，收缩左端点。

```python
ans = init_val
info_needed = 0 # 需要维护的信息
j = 0 # 左端点初值
# 枚举右端点
for i, x in enumerate(nums):
   # 根据题意维护信息
   info_needed += x 
   while info_needed 不满足:
      j += 1
   ans = max/min(ans, i - j)
return ans 
```

#### 相关问题

[Q209] 长度最小的子数组
> - 暴力 O(n2)，枚举子数组的左端点和右端点。
> - 优化，没有利用到数组元素都是正数的特点。枚举右端点，因为都是正数，需要维护的信息，子数组的和会单调增加。

- 方法I 
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        j = 0 # 初始化左端点
        for i, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s - nums[j] >= target: # 可以缩小左端点，思考为什么不判断j<i
                s -= nums[j]
                j += 1
            if s >= target:
                ans = min(ans, i - j + 1)
        return ans if ans <= n else 0
```
- 方法II

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        j = 0 # 初始化左端点
        for i, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s >= target: # 可以更新答案
                ans = min(ans, i - j + 1)
                s -= nums[j]
                j += 1       
        return ans if ans <= n else 0
```


[Q209] 长度最小的子数组


#### 滑动窗口
> 使用场景，在子数组上维护一些信息。求子数组的一些性质，个数，最大值，最小值...

#### 代码模板


```python

```

#### 相关问题

[Q] 不间断子数组
>

```python

```

[//]: # 
   [Q209]: <https://leetcode.cn/problems/minimum-size-subarray-sum/>
