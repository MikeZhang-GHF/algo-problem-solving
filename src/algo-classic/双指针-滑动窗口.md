### 双指针

**07/02/2023**

#### 核心思想
> 本质是数据所有维护的信息具有**单调性**，可以枚举右端点，维护信息，缩小左端点来维护满足条件的信息。不断地更新答案。
> 实现的时候，**可能维护的满足条件**，**可能维护不满足条件**。
> 适用场景，主要在线性的数据结构上。是一种优化技巧，可以降低一个维度。特别是关于**子数组**相关的问题，因为会维护子数组的起点和终点。
> 前提，维护的性质具有单调性，**枚举右端点，收缩左端点**，来维护子数组的信息。左指针是不会回头的。

#### 代码模板
> - **枚举右端点，收缩左端点**，维护信息。而不是枚举左端点，拓展右端点，这样需要判断右端点越界问题。代码实现容易。
> - 右端点无脑滑动，收缩左端点。

```python
ans = init_val
info_needed = 0 # 需要维护的信息
j = 0 # 左端点初值
# 枚举右端点
for i, x in enumerate(nums):
   # 根据题意维护信息
   info_needed += x 
   while info_needed 不满足:
      j += 1
   ans = max/min(ans, i - j)
return ans 
```

#### 相关问题

- 模型I 同向双指针

[Q209] 长度最小的子数组
> - 关键字，子数组。
> - 维护的信息是否具有单调性。维护的是子数组和，都是正数，具有单调性。
> - 优化，如果暴力枚举左端点和右端点，没有利用到数组元素都是正数的特点。枚举右端点，因为都是正数，需要维护的信息，子数组的和会单调增加。

- 方法I 
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        left = 0 # 初始化左端点
        for right, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s - nums[left] >= target: # 可以缩小左端点，思考为什么不判断j<i
                s -= nums[left]
                left += 1
            if s >= target:
                ans = min(ans, right - left + 1)
        return ans if ans <= n else 0
```
- 方法II

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        left = 0 # 初始化左端点
        for right, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s >= target: # 可以更新答案
                ans = min(ans, right - left + 1)
                s -= nums[left]
                left += 1       
        return ans if ans <= n else 0
```

[Q713] 乘积小于K的子数组
> 关键字，子数组。
> 维护的信息，子数组的乘积。都是正数，具有单调性。
> 可以使用同向双指针，维护左右端点信息。

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1: # 乘积必须 > 1
            return 0 
        ans = 0
        left, product = 0, 1
        for right, x in enumerate(nums):
            product *= x # 维护信息
            while product >= k: # 不满足维护信息，不断缩小左端点
                product /= nums[left]
                left += 1
            ans += right - left + 1 # 更新答案
        return ans
```

[Q3] 无重复字符的最长子串
> 关键字，子串。子串对于字符串就是子数组。
> 维护信息单调性，字符出现的次数是具有单调性。子串越长，字符出现的次数越多。
> 维护字符出现的次数可以使用哈希表或者一个长度为26的数组。
> - 时间复杂度 O(n), 
> - 空间复杂度 O(1)。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = 0
        cnt = Counter() # 哈希表
        left = 0
        for right, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] > 1:
                cnt[s[left]] -= 1
                left += 1
            ans = max(ans, right - left + 1)
        return ans 
```

#### 滑动窗口
> 

#### 代码模板


```python

```

#### 相关问题

[Q] 
>

```python

```

[//]: # 
   [Q209]: <https://leetcode.cn/problems/minimum-size-subarray-sum/>
   [Q713]: <https://leetcode.cn/problems/subarray-product-less-than-k/description/>
   [Q3]: <https://leetcode.cn/problems/longest-substring-without-repeating-characters/>
