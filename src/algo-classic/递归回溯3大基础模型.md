### 递归回溯3大基础模型

**06/20/2023**

> 基本所有的递归回溯问题都可以抽象成这三种模型，这三种模型是递归回溯的基础，掌握了这三种模型，就可以解决大部分的递归回溯问题。
> 如果集合的元素不多，可以使用位运算来表示集合，可以看做状态压缩，这样可以减少空间复杂度。详见[集合和二进制]。
> 本质上是一种暴力搜索算法，实现使用递归。对于问题求解，操作后，剩下的问题和原问题一致，都可以使用递归来解决。问题的每一步都有多种选择，递归的每一层都会尝试每一种选择，直到找到一个可行解或者尝试完所有的选择。
> 递归的实现，通常使用一个函数完成，
> - 函数定义 dfs(x1, x2...)函数的参数是当前的状态，函数的返回值是当前状态下的解。
> - 递归边界，递归的终止条件是当前状态下的解已经找到，或者当前状态下没有解。
> - 每一层的操作，思考这一层的操作是什么。每一层的操作是对当前状态的选择，每一层的操作都会改变当前状态，然后递归调用下一层。

#### 子集
> 一个问题可以抽象成从某个集合中选取若干个元素，这个问题就可以使用子集模型来解决。
> 2种解决思路：
> 1. 选或不选 
> 2. 选哪个


#### 组合

#### 排列
> 回溯3问:
> 当前操作？
> 枚举每个位置可以填哪些数？需要的状态是，当前位置i, 当前可以选的数的集合，涉及到集合如果数据范围很小，可以使用位运算来表示集合，可以看做状态压缩，这样可以减少空间复杂度。 


- 模板题
[46] - 全排列

python
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        ans, path = [], [0] * n
        def dfs(s, i):
            if i == n:
                ans.append(path[:])
                return
            
            for j in range(n):
                if (s >> j) & 1: # 某个元素是否可选，1代表可以
                    path[i] = nums[j]
                    dfs(s ^ (1 << j), i + 1) # 将某个元素从集合中去掉，s^(1<<j)
        dfs((1 << n) - 1, 0) # 从全集1111开始枚举
        return ans
```

typescript
```typescript
function permute(nums: number[]): number[][] {
    const n = nums.length
    const ans: number[][] = []
    const path: number[] = Array(n).fill(0)

    const dfs = (s: number, i: number): void => {
        if (i == n) {
            ans.push([...path])
            return 
        }

        for (let j = 0; j < n; j ++ ) {
            if ((s >> j) & 1) {
                path[i] = nums[j];
                dfs(s ^ (1 << j), i + 1)
            }
        }
    }

    dfs((1 << n) - 1, 0)
    return ans
};
```

[2741] - 特殊排列
>使用状态压缩可以优化一些排列问题
>排列模型: 枚举每个位置，每个位置填的数字
>回溯是否有重复计算，如果有，可以利用记忆化搜索。
>dfs(s, i)表示，可选数字集合s,上一个选的数是nums[i],
>是存在重复计算的，比如，1, 2, 4, {} 和 2, 1, 4, {}两个会递归到一个状态里
>所以可以使用记忆化搜索优化,
>dfs(s,i)表示当前可以选的数的集合, 上一个选的数的下表是j
>如果nums[i]%nums[k] == 0 or nums[k]%nums[i] == 0
>dfs(s,i) += sum(dfs(s\{k}, k) for k in s)
>递归边界：dfs(0,i) = 1
>递归入口: dfs(U\{i},i) U = {0, 1, 2, 3...}
>答案sum(dfs(U\{i}, i) for i in range(n))
>知识点：
>1. 全排列回溯
>2. 记忆化搜索
>3. 集合<=>位运算

python
```python
class Solution:
    def specialPerm(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7 
        # @lru_cache(None)
        @cache 
        def dfs(s, i): # s是一个整数用来表示一个集合,i是选的上一个数字的下标
            if s == 0: # all choosen, ans++
                return 1 
            res = 0
            for k, x in enumerate(nums):
                if (s >> k) & 1 and (nums[i] % nums[k] == 0 or nums[k] % nums[i] == 0):
                    res += dfs(s ^ (1 << k), k) # 删除一个元素
            return res 
        n = len(nums)
        u = (1 << n) - 1 # 全集
        return sum(dfs(u ^ (1 << i), i) for i in range(n)) % MOD
```

typescript
```typescript
function specialPerm(nums: number[]): number {
    const MOD = 10 ** 9 + 7

    const dfs = (s: number, i: number): number => {
        if (s == 0)
            return 1
        let res = 0
        for (let k = 0; k < n; k ++ )
            if ((s >> k) & 1 && (nums[i] % nums[k] == 0 || nums[k] % nums[i] == 0))
                res += dfs(s ^ (1 << k), k)
        return res
    }

    const n = nums.length
    const u = (1 << n) - 1
    let ans = 0

    for (let i = 0; i < n; i++) 
        ans += dfs(u ^ (1 << i), i) // 枚举第一个位置填的数字
    
    return ans % MOD
};
```


#### 有用资源
[集合和二进制]



## Go
**Go! Grow together**

[//]: # (These are reference links used in the body of this note and get stripped out when the markdown processor does its job. There is no need to format nicely because it shouldn't be seen.)
   [集合和二进制]: <https://leetcode.cn/circle/discuss/CaOJ45/>
   [46]: <https://leetcode-cn.com/problems/permutations/> 
   [2741]: <https://leetcode.cn/problems/special-permutations/>