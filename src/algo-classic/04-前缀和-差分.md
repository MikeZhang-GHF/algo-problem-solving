### 前缀和
**07/20/2023**

#### 核心思想
> - 解决的问题，一般是求一个区间的和/子数组的和，暴力是$`O(n^2)`$，前缀和是$`O(n)`$。
> - 前缀和数组: $`sum[i] = \sum_{j=0}^{i-1} nums[j]`$
> - 对于任意一个区间$`[l, r]`$，$`sum[r] - sum[l-1] = \sum_{j=l-1}^{r} nums[j]`$，即区间和。

#### 代码模板
**一维前缀和**，为了便于处理边界，下标从1开始。
```python
def prefixSum(nums):
    n = len(nums)
    sum = [0] * (n + 1)
    for i in range(1, n + 1):
        sum[i] = sum[i - 1] + nums[i - 1]
    return sum 
```

**二维前缀和**
[Q304] - Range Sum Query 2D - Immutable
> 矩形**右下角**的前缀和，$`s[i][j]`$表示矩形(1, 1)到(i, j)的和。
> $`s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + nums[i-1][j-1]`$

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        n, m = len(matrix), len(matrix[0])
        # 下标从1开始，为了处理边界
        self.s = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                self.s[i][j] = self.s[i - 1][j] + self.s[i][j - 1] - self.s[i - 1][j - 1] + matrix[i - 1][j - 1] 


    def sumRegion(self, x1: int, y1: int, x2: int, y2: int) -> int:
        # 下标从1开始
        x1, y1, x2, y2 = x1 + 1, y1 + 1, x2 + 1, y2 + 1
        return self.s[x2][y2] - self.s[x2][y1 - 1] - self.s[x1 - 1][y2] + self.s[x1 - 1][y1 - 1]
```

### 差分

#### 核心思想
> 解决的问题是，对于一个区间$`[l, r]`$，给区间内的每个元素加上一个值$`c`$，暴力是$`O(n^2)`$，差分是$`O(n)`$。
> 差分数组: $`diff[i] = nums[i] - nums[i-1]`$
> **打标记**，区间开始的时候加上$`c`$，区间结束的时候减去$`c`$，区间外的元素不变。
> 对于标记数组进行求**前缀和**，就可以得到答案。

#### 代码模板
[Q1109] - Corporate Flight Bookings
> 操作的是一个区间，对于区间$`[l, r]`$，给区间内的每个元素加上一个值$`c`$。使用差分可以高效的处理这个问题。
>
```python
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        b = [0] * (n + 2) # 差分数组，下标从1开始，对于最后一个元素，+1
        for l, r, c in bookings:
            b[l] += c 
            b[r + 1] -= c 
        for i in range(1, n + 1):
            b[i] += b[i - 1]
        return b[1:n + 1]
```

[Q2536] - Inmcrement Submatrices by One
> 在一个二维矩阵上，对于一个区间$`[x1, y1, x2, y2]`$，给区间内的每个元素加上一个值$`c`$。使用差分可以高效的处理这个问题。
> 对于矩阵进行4个标记，左上角加上$`c`$，右上角减去$`c`$，左下角减去$`c`$，右下角加上$`c`$。
> 然后用前缀和求出答案。注意，前缀和和差分的时候，下标从1开始，为了处理边界，差分数组+2。
> 
```python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        diff = [[0] * (n + 2) for _ in range(n + 2)]
        for x1, y1, x2, y2 in queries:
            diff[x1 + 1][y1 + 1] += 1
            diff[x1 + 1][y2 + 2] -= 1
            diff[x2 + 2][y1 + 1] -= 1
            diff[x2 + 2][y2 + 2] += 1
        
        ans = [[0] * n for _ in range(n)]
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1]
                ans[i - 1][j - 1] = diff[i][j]
        return ans
```

#### 相关问题

[Q2772] Apply Operations to Make Array Elements Equal to Zero 
> - 每个子数组加上一个值，使得数组中所有元素都变成0，求最少的操作次数。暴力是$`O(n^2)`$，差分是$`O(n)`$。
> - 模拟操作。
> - 时间复杂度: $`O(n)`$，其中n为数组长度。
> - 空间复杂度: $`O(n)`$。


```python
class Solution:
    def checkArray(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        d = [0] * (n + 1) # 差分数组,n+1为着处理最后一个差分
        sum_d = 0 
        for i, x in enumerate(nums):
            sum_d += d[i]
            x += sum_d 
            # x < 0:
            if x < 0:
                return False
            # x = 0
            if x == 0:
                continue 
            # x > 0
            if i+k > n: # 无法操作
                return False
            sum_d -= x # d[i] -= x 
            d[i+k] += x
        return True
```



[//]: #
  [Q304]: <https://leetcode.com/problems/range-sum-query-2d-immutable/>
  [Q1109]: <https://leetcode.com/problems/corporate-flight-bookings/>
  [Q2536]: <https://leetcode.com/problems/increment-submatrices-by-one/>
  [Q792]: <https://leetcode.com/problems/number-of-matching-subsequences/>
  [Q2772]: <https://leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/>