### 枚举

#### 核心思想
> 最简单和直接的思想，将所有情况全部枚举出来，本质是暴力思想。
> - 没有思路的
> - 注意枚举的顺序，代码的实现难度可能不同。

#### 相关问题

[Q2768] 黑格子的数目
> - 关键字，计算包含黑格子的子矩阵个数。
> - 稀疏矩阵，枚举黑格子周围的子矩阵即可。
> - 枚举矩阵常用技巧，都是枚举矩阵的右下角。
> - 枚举的时候，注意越界的问题，通常是[max(x, size - 1), min(x+size, m)]，size就是矩阵的维度。
> - 注意去重，使用set和坐标变成tuple进行去重。
> - 最后计算含有0个黑格子的子矩阵，使用补集的思想，所有的格子 - 至少含有一个黑格子的数量。

- 方法I 枚举包含黑格子的矩形的右下角
```python
class Solution:
    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:
        # 枚举矩形的右下角，会包含4个格子
        # 包含黑格子(x,y)的4个子矩阵的右下角, i=x,x+1, j=y,y+1
        s = set(map(tuple, coordinates))
        ans = [0] * 5
        vis = set()
        for x, y in coordinates:
            for i in range(max(x, 1), min(x+2, m)): # 枚举右下角x=[1,x+1], y=[1,y+1]
                for j in range(max(y, 1), min(y+2, n)):
                    if (i,j) not in vis:
                        vis.add((i,j))
                        # 含有黑格子的四个子矩阵的右下角
                        cnt = ((i,j) in s) + ((i,j-1) in s) + ((i-1,j) in s) + ((i-1,j-1) in s)
                        ans[cnt] += 1
        ans[0] = (m-1) * (n-1) - len(vis) # 补集思想，所有的格子-至少有一个的格子，就是0个格子的个数
        return ans 
```

- 方法II 贡献法，每个矩阵贡献

```python
class Solution:
    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:
        # 枚举矩形的右下角，会包含4个格子
        # 包含黑格子(x,y)的4个子矩阵的右下角, i=x,x+1, j=y,y+1
        s = set(map(tuple, coordinates))
        ans = [0] * 5
        cnt = Counter()
        for x, y in coordinates:
            for i in range(max(x, 1), min(x+2, m)): # 枚举右下角x=[1,x+1], y=[1,y+1]
                for j in range(max(y, 1), min(y+2, n)):
                    cnt[(i,j)] += 1
        ans[0] = (m-1) * (n-1) - len(cnt) # 补集思想，所有的格子-至少有一个的格子，就是0个格子的个数
        # 统计含有1,2,3,4黑格子的数量的数量
        cc = Counter(cnt.values())
        for i in range(1, 5):
            ans[i] = cc[i]
        return ans 
```

[//]: #

  [Q2768]: <https://leetcode.cn/problems/number-of-black-blocks/>
  [Q]