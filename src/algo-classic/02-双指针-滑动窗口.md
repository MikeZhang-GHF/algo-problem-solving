### 双指针

**07/02/2023**

#### 核心思想
> 本质是数据所有维护的信息具有**单调性**，可以枚举右端点，维护信息，缩小左端点来维护满足条件的信息。不断地更新答案。
> 实现的时候，**可能维护的满足条件**，**可能维护不满足条件**。
> 适用场景，主要在线性的数据结构上。是一种优化技巧，可以降低一个维度。特别是关于**子数组**相关的问题，因为会维护子数组的起点和终点。
> 前提，维护的性质具有单调性，枚举left，拓展right，来维护子数组的信息。右指针是不会回头的。

#### 代码模板
> - 枚举右端点，收缩左端点，维护信息。而不是枚举左端点，拓展右端点，这样需要判断右端点越界问题。代码实现容易。
> - 右端点无脑滑动，收缩左端点。

```python
ans = init_val
info_needed = 0 # 需要维护的信息
j = 0 # 左端点初值
# 枚举右端点
for i, x in enumerate(nums):
   # 根据题意维护信息
   info_needed += x 
   while info_needed 不满足:
      j += 1
   ans = max/min(ans, i - j)
return ans 
```

#### 相关问题

- 模型I 同向双指针

[Q209] 长度最小的子数组
> - 关键字，子数组。
> - 维护的信息是否具有单调性。维护的是子数组和，都是正数，具有单调性。
> - 优化，如果暴力枚举左端点和右端点，没有利用到数组元素都是正数的特点。枚举右端点，因为都是正数，需要维护的信息，子数组的和会单调增加。

- 方法I 
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        left = 0 # 初始化左端点
        for right, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s - nums[left] >= target: # 可以缩小左端点，思考为什么不判断j<i
                s -= nums[left]
                left += 1
            if s >= target:
                ans = min(ans, right - left + 1)
        return ans if ans <= n else 0
```
- 方法II

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        left = 0 # 初始化左端点
        for right, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s >= target: # 可以更新答案
                ans = min(ans, right - left + 1)
                s -= nums[left]
                left += 1       
        return ans if ans <= n else 0
```

[Q713] 乘积小于K的子数组
> - 关键字，子数组。
> - 维护的信息，子数组的乘积。都是正数，具有单调性。
> - 可以使用同向双指针，维护左右端点信息。

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1: # 乘积必须 > 1
            return 0 
        ans = 0
        left, product = 0, 1
        for right, x in enumerate(nums):
            product *= x # 维护信息
            while product >= k: # 不满足维护信息，不断缩小左端点
                product /= nums[left]
                left += 1
            ans += right - left + 1 # 更新答案
        return ans
```

[Q3] 无重复字符的最长子串
> - 关键字，子串。子串对于字符串就是子数组。
> - 维护信息单调性，字符出现的次数是具有单调性。子串越长，字符出现的次数越多。
>  维护字符出现的次数可以使用哈希表或者一个长度为26的数组。
> - 时间复杂度 O(n), 
> - 空间复杂度 O(1)。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = 0
        cnt = Counter() # 哈希表
        left = 0
        for right, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] > 1:
                cnt[s[left]] -= 1
                left += 1
            ans = max(ans, right - left + 1)
        return ans 
```



- 模型II 相向双指针

[Q167] 两数之和 II - 输入有序数组
> - 关键字有序，具有单调性。
> - 将最大和最小的数求和，x+y根据和target的比较，进行移动指针。因为单调性，指针移动不会回头，左右指针相向移动，直到差一。
> - 时间复杂度 O(n)
> - 空间复杂度 O(1)

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            s = numbers[left] + numbers[right]
            if s == target:
                return [left + 1, right + 1]
            elif s < target:
                left += 1
            else:
                right -= 1
        
        return []
```

[Q15] 三数之和
> - 关键字，数对，跟次序无关，可以排序。
> - a + b + c = 0 => a + b = - c，两数之和模型。但是得先排序。
> - 去重，排序后，相同的数字会在一起，所以一个数和上一个数相同，就跳过。
> - 经典问题，去重技巧，还有优化技巧。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n-2):
            x = nums[i]
            # skip the duplicates for x
            if i > 0 and nums[i] == nums[i-1]:
                continue 
            j = i + 1
            k = n - 1
            while j < k:
                s = x + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    ans.append([x, nums[j], nums[k]])
                    # 去重
                    j += 1
                    while j < k and nums[j] == nums[j-1]:
                        j += 1
                    k -= 1
                    while k > j and nums[k] == nums[k+1]:
                        k -= 1
        return ans 
                    
```

- 优化版

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n-2):
            x = nums[i]
            # skip the duplicates for x
            if i > 0 and nums[i] == nums[i-1]:
                continue 

            # 优化 1 和最小的两个数相加都大于0，后面的更大，break
            if x + nums[i+1] + nums[i+2] > 0:
                break
            # 优化 2 和最大的两个数相加都小于0，前面的更小，枚举下一个x
            if x + nums[-1] + nums[-2] < 0:
                continue 

            # 有序数组两数之和问题
            j = i + 1
            k = n - 1
            while j < k:
                s = x + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    ans.append([x, nums[j], nums[k]])
                    # 去重
                    j += 1
                    while j < k and nums[j] == nums[j-1]:
                        j += 1
                    k -= 1
                    while k > j and nums[k] == nums[k+1]:
                        k -= 1
        return ans                     
```

[Q11] 盛最多水的容器
> - 关键字，左右两个边界的高度和之间的距离维护矩形的面积信息。求最大。
> - 维护高度变小，宽度也变小。所以，左右边界较短的不会构成更大的矩形面积。可以去掉。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        left, right = 0, n - 1
        ans = 0
        while left < right:
            ans = max(ans, min(height[left], height[right]) * (right - left))
            # 移动指针，谁短移动谁
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1 
        return ans
```

[Q42] 接雨水
> 方法I 前后缀分解
> - 计算雨水的总面积，可以枚举每个位置的雨水，每个位置的雨水取决于左右柱子的最大值。
> - 维护每个位置左右柱子的最大值，也就是前缀和后缀的最大值。可以使用2个数组来维护，也可以使用一个数组来维护后缀最大值，前缀最大值可以使用一个变量，一边计算一边维护。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        # 维护前缀最大值信息
        suf_max = [0] * n
        suf_max[n - 1] = height[-1]
        for i in range(n-2, -1, -1):
            suf_max[i] = max(suf_max[i+1], height[i])
        # 维护后缀最大值信息
        pre_max = [0] * n
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i-1], height[i])
        
        ans = 0 
        for h, pre, suf in zip(height, pre_max, suf_max):
            ans += min(pre, suf) - h 
        return ans 
```
> 方法II 前后缀分解 + 双指针
> 在前面的前后缀分解的思路上，可以比较前后缀的最大值，前缀小，计算水量，并且可以向右拓展。后缀小，计算水量，并且可以向左拓展。可以使用双指针来维护左右边界的位置。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        ans = 0
        left, right = 0, n - 1
        pre_max, suf_max = 0, 0
        ans = 0
        while left <= right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                ans += pre_max - height[left]
                left += 1
            else:
                ans += suf_max - height[right]
                right -= 1 
        return ans
```

> 方法III 单调栈


#### 分组循环
> 在线性数据中，需要找出满足要求的某些段，将数据进行分组。本质就是维护子数组的信息。比较不容易写错的方法
> - 两个while循环，外层枚举子段的起点，内层寻找子段的终点。和通常的双指针和滑动窗口实现不同，枚举右端点，收缩左端点不同。
> - 可能会有回退起点i，根据题意，如果子段之间有重合的情况。

```python
    def group(self, nums: List[int]) -> int:
        ans = -1
        i, n = 0, len(nums)
        # 无法写成for因为我们会灵活的调整i
        while i < n - 1: 
            if nums[i+1] - nums[i] != 1: # 跳过不满足条件
                i += 1
                continue 
            j = i # 保存子数组的起点
            i += 1 # 拓展右端点
            # 交替，b[i]=b[i-2]=b[i-4]，T=2，b[i]=b[i%2]
            while i < n and nums[i] == nums[j + (i-j)%2]: 
                i += 1 # 拓展右端点
            ans = max(ans, i - j) # [i, j)
            i -= 1 # 通常不回退，但是这道题比较特殊有重叠部分 3434545
        return ans 
```

[Q2765] 最长交替子序列
> - 关键字 交替，循环，子数组。
> - 使用双指针可以维护子数组信息。外层循环，枚举子数组的起点，内层循环，拓展子数组的终点。
> - 这道题可以当成模板，但是会回退一下右指针，处理一下edge case，3434545的特殊情况，会有重叠情况。

```python
class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        ans = -1
        i, n = 0, len(nums)
        # 无法写成for因为我们会灵活的调整i
        while i < n - 1: 
            if nums[i+1] - nums[i] != 1: # 跳过不满足条件
                i += 1
                continue 
            j = i # 保存子数组的起点
            i += 1 # 拓展右端点
            # 交替，b[i]=b[i-2]=b[i-4]，T=2，b[i]=b[i%2]
            while i < n and nums[i] == nums[j + (i-j)%2]: 
                i += 1 # 拓展右端点
            ans = max(ans, i - j) # [i, j)
            i -= 1 # 通常不回退，但是这道题比较特殊有重叠部分 3434545
        return ans 
```


```python
class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        ans = i = 0
        n = len(nums)
        # 分组循环，找到起点j，拓展右端点i
        while i < n:
            x = nums[i]
            # 不满足分组条件，跳过
            if x > threshold or x & 1:
                i += 1
                continue 
            j = i # 记住左端点
            i += 1 # 至少2个数
            # 满足条件拓展右端点i
            while i < n and nums[i] <= threshold and nums[i] % 2 != nums[i-1] % 2:
                i += 1
            ans = max(ans, i - j) #[i, j) # 这道题不需要回退
        return ans 
```

[Q2760] 最长奇偶子数组
> - 关键字，子数组，相邻之间数据的关系。是一个分组的双指针的问题。
> - 使用分组循环的模板。

```python
class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        ans = i = 0
        n = len(nums)
        # 分组循环，找到起点j，拓展右端点i
        while i < n:
            x = nums[i]
            # 不满足分组条件，跳过
            if x > threshold or x & 1:
                i += 1
                continue 
            j = i # 记住左端点
            i += 1 # 至少2个数
            # 满足条件拓展右端点i
            while i < n and nums[i] <= threshold and nums[i] % 2 != nums[i-1] % 2:
                i += 1
            ans = max(ans, i - j) #[i, j) # 这道题不需要回退
        return ans  
```


#### 滑动窗口
> 本质上就是一个相向双指针算法，维护一段信息，利用某种性质，具有单调性，枚举右端点，左端点一定跟随向右，不会向左。
> 窗口的大小可以是固定的，通常固定；也可以是可变的，根据题意来定。

#### 代码模板
> - 枚举右端点，一次加入一个新的信息
> - 根据维护的信息，可以满足条件，也可以不满足条件来缩小左端点(跟随右端点)
> - 更新答案

#### 相关问题

[Q2762] 不间断子数组
> - 关键字，子数组，考虑双指针。
> - 维护的信息，abs(最大值-最小值) <= 2，枚举右端点，加入一个新的数字，如果abs(mx-mn)>2，左边的指针一定向右移动，具有单调性。
> - 如何维护子数组中的最大值和最小值，可能有重复数字，这里是2，窗口的大小是3，最多有4个数，可以使用哈希表来进行维护。
> - 拓展，如果abs(最大值-最小值) <= K，K可能是很大，这道题就变成了滑动窗口(窗口大小为K)求最大值和最小值的经典问题，可以使用单调队列来解决。

```python
class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        ans = 0
        left = 0 
        cnt = Counter()
        for right, x in enumerate(nums):
            cnt[x] += 1
            while max(cnt) - min(cnt) > 2:
                y = nums[left]
                cnt[y] -= 1
                if cnt[y] == 0:
                    del cnt[y]
                left += 1
            ans += right - left + 1 
        return ans 
```

[Q1438] - 绝对差不超过限制的最长连续子数组
> - 关键字，子数组，可以考虑双指针来维护子数组的信息。
> - 这是上道题的拓展。可以使用2个单调队列来维护最大值和最小值。但是，也可以使用python的SortedList来维护有序序列，支持插入，删除等操作，保持有序序列。

```python
from sortedcontainers import SortedList

class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        ans = 0 
        left = 0
        sl = SortedList()
        for right, x in enumerate(nums):
            sl.add(x)
            while sl[-1] - sl[0] > limit:
                sl.remove(nums[left])
                left += 1 
            ans = max(ans, right - left + 1)
        return ans 
```

[//]: # 
   [Q209]: <https://leetcode.cn/problems/minimum-size-subarray-sum/>
   [Q713]: <https://leetcode.cn/problems/subarray-product-less-than-k/description/>
   [Q3]: <https://leetcode.cn/problems/longest-substring-without-repeating-characters/>
   [Q209]: <https://leetcode.cn/problems/minimum-size-subarray-sum/> 
   [Q167]: <https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/>
   [Q15]: <https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/>
   [Q11]: <https://leetcode.cn/problems/container-with-most-water/>
   [Q42]: <https://leetcode.cn/problems/trapping-rain-water/>
   [Q2760]: <https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/description/> 
   [Q2765]: <https://leetcode.cn/problems/longest-alternating-subarray/>
   [Q2762]: <https://leetcode.cn/problems/continuous-subarrays/description/>
   [Q1438]: <https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/>