### 双指针

**07/02/2023**

#### 核心思想
> 本质是数据所有维护的信息具有**单调性**，可以枚举右端点，维护信息，缩小左端点来维护满足条件的信息。不断地更新答案。
> 实现的时候，**可能维护的满足条件**，**可能维护不满足条件**。
> 适用场景，主要在线性的数据结构上。是一种优化技巧，可以降低一个维度。特别是关于**子数组**相关的问题，因为会维护子数组的起点和终点。
> 前提，维护的性质具有单调性，枚举left，拓展right，来维护子数组的信息。右指针是不会回头的。

#### 代码模板
> - 枚举右端点，收缩左端点，维护信息。而不是枚举左端点，拓展右端点，这样需要判断右端点越界问题。代码实现容易。
> - 右端点无脑滑动，收缩左端点。

```python
ans = init_val
info_needed = 0 # 需要维护的信息
j = 0 # 左端点初值
# 枚举右端点
for i, x in enumerate(nums):
   # 根据题意维护信息
   info_needed += x 
   while info_needed 不满足:
      j += 1
   ans = max/min(ans, i - j)
return ans 
```

#### 相关问题

- 模型I 同向双指针

[Q209] 长度最小的子数组
> - 关键字，子数组。
> - 维护的信息是否具有单调性。维护的是子数组和，都是正数，具有单调性。
> - 优化，如果暴力枚举左端点和右端点，没有利用到数组元素都是正数的特点。枚举右端点，因为都是正数，需要维护的信息，子数组的和会单调增加。

- 方法I 
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        left = 0 # 初始化左端点
        for right, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s - nums[left] >= target: # 可以缩小左端点，思考为什么不判断j<i
                s -= nums[left]
                left += 1
            if s >= target:
                ans = min(ans, right - left + 1)
        return ans if ans <= n else 0
```
- 方法II

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1
        s = 0 # 维护的信息 - 子数组和
        left = 0 # 初始化左端点
        for right, x in enumerate(nums): # 枚举右端点
            s += x # 更新维护的信息
            while s >= target: # 可以更新答案
                ans = min(ans, right - left + 1)
                s -= nums[left]
                left += 1       
        return ans if ans <= n else 0
```

[Q713] 乘积小于K的子数组
> - 关键字，子数组。
> - 维护的信息，子数组的乘积。都是正数，具有单调性。
> - 可以使用同向双指针，维护左右端点信息。

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1: # 乘积必须 > 1
            return 0 
        ans = 0
        left, product = 0, 1
        for right, x in enumerate(nums):
            product *= x # 维护信息
            while product >= k: # 不满足维护信息，不断缩小左端点
                product /= nums[left]
                left += 1
            ans += right - left + 1 # 更新答案
        return ans
```

[Q3] 无重复字符的最长子串
> 关键字，子串。子串对于字符串就是子数组。
> 维护信息单调性，字符出现的次数是具有单调性。子串越长，字符出现的次数越多。
> 维护字符出现的次数可以使用哈希表或者一个长度为26的数组。
> - 时间复杂度 O(n), 
> - 空间复杂度 O(1)。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = 0
        cnt = Counter() # 哈希表
        left = 0
        for right, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] > 1:
                cnt[s[left]] -= 1
                left += 1
            ans = max(ans, right - left + 1)
        return ans 
```

- 模型II 相向双指针

[Q167] 两数之和 II - 输入有序数组
> - 关键字有序，具有单调性。
> - 将最大和最小的数求和，x+y根据和target的比较，进行移动指针。因为单调性，指针移动不会回头，左右指针相向移动，直到差一。
> - 时间复杂度 O(n)
> - 空间复杂度 O(1)

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            s = numbers[left] + numbers[right]
            if s == target:
                return [left + 1, right + 1]
            elif s < target:
                left += 1
            else:
                right -= 1
        
        return []
```

[Q15] 三数之和
> - 关键字，数对，跟次序无关，可以排序。
> - a + b + c = 0 => a + b = - c，两数之和模型。但是得先排序。
> - 去重，排序后，相同的数字会在一起，所以一个数和上一个数相同，就跳过。
> - 经典问题，去重技巧，还有优化技巧。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n-2):
            x = nums[i]
            # skip the duplicates for x
            if i > 0 and nums[i] == nums[i-1]:
                continue 
            j = i + 1
            k = n - 1
            while j < k:
                s = x + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    ans.append([x, nums[j], nums[k]])
                    # 去重
                    j += 1
                    while j < k and nums[j] == nums[j-1]:
                        j += 1
                    k -= 1
                    while k > j and nums[k] == nums[k+1]:
                        k -= 1
        return ans 
                    
```

- 优化版

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n-2):
            x = nums[i]
            # skip the duplicates for x
            if i > 0 and nums[i] == nums[i-1]:
                continue 

            # 优化 1 和最小的两个数相加都大于0，后面的更大，break
            if x + nums[i+1] + nums[i+2] > 0:
                break
            # 优化 2 和最大的两个数相加都小于0，前面的更小，枚举下一个x
            if x + nums[-1] + nums[-2] < 0:
                continue 

            # 有序数组两数之和问题
            j = i + 1
            k = n - 1
            while j < k:
                s = x + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    ans.append([x, nums[j], nums[k]])
                    # 去重
                    j += 1
                    while j < k and nums[j] == nums[j-1]:
                        j += 1
                    k -= 1
                    while k > j and nums[k] == nums[k+1]:
                        k -= 1
        return ans                     
```

[Q11] 盛最多水的容器
> - 关键字，左右两个边界的高度和之间的距离维护矩形的面积信息。求最大。
> - 维护高度变小，宽度也变小。所以，左右边界较短的不会构成更大的矩形面积。可以去掉。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        left, right = 0, n - 1
        ans = 0
        while left < right:
            ans = max(ans, min(height[left], height[right]) * (right - left))
            # 移动指针，谁短移动谁
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1 
        return ans
```

[Q42] 接雨水
> 方法I 前后缀分解
> - 计算雨水的总面积，可以枚举每个位置的雨水，每个位置的雨水取决于左右柱子的最大值。
> - 维护每个位置左右柱子的最大值，也就是前缀和后缀的最大值。可以使用2个数组来维护，也可以使用一个数组来维护后缀最大值，前缀最大值可以使用一个变量，一边计算一边维护。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        # 维护前缀最大值信息
        suf_max = [0] * n
        suf_max[n - 1] = height[-1]
        for i in range(n-2, -1, -1):
            suf_max[i] = max(suf_max[i+1], height[i])
        # 维护后缀最大值信息
        pre_max = [0] * n
        pre_max[0] = height[0]
        for i in range(1, n):
            pre_max[i] = max(pre_max[i-1], height[i])
        
        ans = 0 
        for h, pre, suf in zip(height, pre_max, suf_max):
            ans += min(pre, suf) - h 
        return ans 
```
> 方法II 前后缀分解 + 双指针
> 在前面的前后缀分解的思路上，可以比较前后缀的最大值，前缀小，计算水量，并且可以向右拓展。后缀小，计算水量，并且可以向左拓展。可以使用双指针来维护左右边界的位置。

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        ans = 0
        left, right = 0, n - 1
        pre_max, suf_max = 0, 0
        ans = 0
        while left <= right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                ans += pre_max - height[left]
                left += 1
            else:
                ans += suf_max - height[right]
                right -= 1 
        return ans
```

> 方法III 单调栈


#### 滑动窗口
> 

#### 代码模板


```python

```

#### 相关问题

[Q] 
>

```python

```

[//]: # 
   [Q209]: <https://leetcode.cn/problems/minimum-size-subarray-sum/>
   [Q713]: <https://leetcode.cn/problems/subarray-product-less-than-k/description/>
   [Q3]: <https://leetcode.cn/problems/longest-substring-without-repeating-characters/>

   [Q167]: <https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/>

   [Q15]: <https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/>

   [Q11]: <https://leetcode.cn/problems/container-with-most-water/>

   [Q42]: <https://leetcode.cn/problems/trapping-rain-water/>