### 线段树

**07/25/2023**

#### 核心思想
> 适用的场景，维护区间的信息，比如区间和，区间极值，公约数，等等和数学相关。
> 1. 单点修改，区间查询。
> 2. 区间修改，区间查询。
> 主要的思想是空间换时间，使用分治的思想，将区间分成若干个小区间，每个小区间维护一个信息，然后将这些信息并起来，就可以得到整个区间的信息。
> 查询的时间复杂度降为$`O(logn)`$，修改的时间复杂度降为$`O(logn)`$。

#### 代码模板 
> - build函数，构建线段树。
> - update函数，单点修改。
> - query函数，区间查询。
> **lazy标记，区间修改，区间查询**
> - modify函数，区间修改。
> - pushdown函数，区间修改时，将修改的信息传递给子节点。
> - pushup函数，区间修改时，将子节点的信息传递给父节点。

```python
    def build(o: int, l: int, r: int) -> None:
        if l == r:
            # 维护当前节点的信息
            return
        mid = l + r >> 1
        build(o << 2, l, mid) # 左子树
        build(o << 2 | 1, mid + 1, r) # 右子树
        # 维护当前节点的信息，比如求和，求最大/小值
    
    def update(o: int, l: int, r: int, index: int, val: int):
        if l == r:
            _sum[o] = nums[l - 1]
            return 
        
        mid = l + r >> 1
        if idx <= mid: update(o << 1, l, mid, index, val)
        if idx > mid: update(o << 1 | 1, mid + 1, index, val)
        # 维护当前节点的信息，比如求和，求最大/小值
            
    
    def update(o: int, l: int, r: int, L: int, R: int) -> None:
        if L <= l and r <= R:
            # 更新当前节点o的信息
            return
        mid = l + r >> 1
        if L <= mid:
            update(o << 2, l, mid, L, R) # 左子树
        if mid < R:
            update(o << 2 | 1, mid + 1, r, L, R) # 右子树
        # 维护当前节点的信息，比如求和，求最大/小值

    # lazy tag
    def update(o: int, l: int, r: int, L: int, R: int, add: int) -> None:
        if L <= l and r <= R:
            # 更新当前节点o的信息
            todo[o] += add
            return

        if todo[o] != 0: # 产生了传递，需要递归下去给左右儿子
            todo[o << 1] += todo[o]
            todo[o << 1 | 1] += todo[o]
            todo[o] = 0

        mid = l + r >> 1
        if L <= mid:
            update(o << 2, l, mid, L, R, add) # 左子树
        if mid < R:
            update(o << 2 | 1, mid + 1, r, L, R, add) # 右子树
        # 维护当前节点的信息，比如求和，求最大/小值
    
    def query(o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R:
            return _sum[o]
        res = 0
        mid = l + r >> 1
        if L <= mid: 
            res += query(o << 1, l, mid, L, R)
        if mid < R:
            res += query(o << 1 | 1, mid + 1, r, L, R)
        return res 
```


- 模板题
[Q307] Range Sum Query - Mutable
> - 关键字，单点修改，区间查询，维护区间和，线段树的经典应用场景。
> - 时间复杂度，$`O(logn)`$。
> - 空间复杂度，$`O(n)`$。
>

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.n = len(nums)
        self.nums = nums
        self.sum = [0] * (4 * self.n)
        self._build(1, 1, self.n)

    def _build(self, o, l, r):
        if l == r:
            self.sum[o] = self.nums[l - 1] # 线段树下标从1开始
            return 
        mid = l + r >> 1
        self._build(o << 1, l, mid)
        self._build(o << 1 | 1, mid + 1, r)
        self.sum[o] = self.sum[o << 1] + self.sum[o << 1 | 1]
    

    def _update(self, o, l, r, idx, val):
        if l == r:
            self.sum[o] = val
            return 
        mid = l + r >> 1
        if idx <= mid:
            self._update(o << 1, l, mid, idx, val)
        if idx > mid:
            self._update(o << 1 | 1, mid + 1, r, idx, val)
        self.sum[o] = self.sum[o << 1] + self.sum[o << 1 | 1]
        

    def _query(self, o: int, l: int, r: int, L: int, R: int):
        if L <= l and r <= R:
            return self.sum[o]
        
        res = 0
        mid = l + r >> 1
        if L <= mid:
            res += self._query(o << 1, l, mid, L, R)
        if mid < R:
            res += self._query(o << 1 | 1, mid + 1, r, L, R)
        return res 

    def update(self, index: int, val: int) -> None:
        self._update(1, 1, self.n, index + 1, val)
        

    def sumRange(self, left: int, right: int) -> int:
        return self._query(1, 1, self.n, left + 1, right + 1)
```

#### 相关问题
[Q2286] Booking Concert Tickets in Groups
> - 关键字，维护连续一段信息，单点修改，区间查询，维护区间和，区间和的最小值两个信息，线段树的经典应用场景。
> - 时间复杂度，$`O((n+q)logn)`$。
> - 空间复杂度，$`O(n)`$。

```python
class BookMyShow:

    def __init__(self, n: int, m: int):
        self.n = n
        self.m = m
        self.sum = [0] * (4 * n)
        # 一排至少有k个空位=>元素个数 <= m-k
        # 可以维护每一排的元素个数的最小值，如果最小值 <= m-k，可以满足
        self.min = [0] * (4 * n) 
    
    # add val for num at idx
    # add(1, 1, n, idx, val) (1, 1, n) 根节点管辖的范围[1,n]
    def add(self, o: int, l: int, r: int, idx: int, val: int) -> None:
        if l == r:
            self.sum[o] += val
            self.min[o] += val
            return 
        
        mid = l + r >> 1
        if idx <= mid:
            self.add(o << 1, l, mid, idx, val)
        else:
            self.add(o << 1 | 1, mid + 1, r, idx, val)
        self.sum[o] = self.sum[o << 1] + self.sum[o << 1 | 1]
        self.min[o] = min(self.min[o << 1], self.min[o << 1 | 1])
    
    # query(1, 1, n, L, R)
    def query(self, o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R:
            return self.sum[o]
        
        res = 0
        mid = l + r >> 1
        if L <= mid:
            res += self.query(o << 1, l, mid, L, R)
        if R > mid:
            res += self.query(o << 1 | 1, mid + 1, r, L, R)

        return res 
    
    # index(1, 1, n, L, R, val)找到第一个满足有k个座位的排
    # [1, R]范围内的<=val的最小下标，val就是m-k，不存在返回0
    def index(self, o: int, l: int, r: int, R: int, val: int) -> int:
        if self.min[o] > val:
            return 0
        if l == r:
            return l
        
        mid = l + r >> 1
        if self.min[o << 1] <= val: # [1, R]，直接检查左子树即可
            return self.index(o << 1, l, mid, R, val)
        if R > mid:
            return self.index(o << 1 | 1, mid + 1, r, R, val)
        return 0


    def gather(self, k: int, maxRow: int) -> List[int]:
        i = self.index(1, 1, self.n, maxRow + 1, self.m - k)
        if i == 0:
            return []
        seats = self.query(1, 1, self.n, i, i) # 查询第i排
        self.add(1, 1, self.n, i, k) # 第i排坐k个人
        return [i - 1, seats]


    def scatter(self, k: int, maxRow: int) -> bool:
        seats_available = (maxRow + 1) * self.m - self.query(1, 1, self.n, 1, maxRow + 1)
        if seats_available < k:
            return False
        
        # 找到第一个有位置的排
        i = self.index(1, 1, self.n, maxRow + 1, self.m - 1)
        while True:
            cur_seats_available = self.m - self.query(1, 1, self.n, i, i)
            if k <= cur_seats_available:
                self.add(1, 1, self.n, i, k)
                return True
            k -= cur_seats_available
            self.add(1, 1, self.n, i, cur_seats_available)
            i += 1
```

[//]: # 
   [Q307]: <https://leetcode.com/problems/range-sum-query-mutable/>
   [Q2286]: <https://leetcode.com/problems/booking-concert-tickets-in-groups/>
   [Q2286]: <https://leetcode.com/problems/booking-concert-tickets-in-groups/>
