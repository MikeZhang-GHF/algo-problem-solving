### 线段树

**07/25/2023**

#### 核心思想
> 适用的场景，维护区间的信息，比如区间和，区间极值，公约数，等等和数学相关。
> 1. 单点修改，区间查询。
> 2. 区间修改，区间查询。
> 主要的思想是空间换时间，使用分治的思想，将区间分成若干个小区间，每个小区间维护一个信息，然后将这些信息并起来，就可以得到整个区间的信息。
> 查询的时间复杂度降为$`O(logn)`$，修改的时间复杂度降为$`O(logn)`$。

#### 代码模板 
> - build函数，构建线段树。
> - update函数，单点修改。
> - query函数，区间查询。
> **lazy标记，区间修改，区间查询**
> - modify函数，区间修改。
> - pushdown函数，区间修改时，将修改的信息传递给子节点。
> - pushup函数，区间修改时，将子节点的信息传递给父节点。

```python
    def build(o: int, l: int, r: int) -> None:
        if l == r:
            # 维护当前节点的信息
            return
        mid = l + r >> 1
        build(o << 2, l, mid) # 左子树
        build(o << 2 | 1, mid + 1, r) # 右子树
        # 维护当前节点的信息，比如求和，求最大/小值
    
    def update(o: int, l: int, r: int, index: int, val: int):
        if l == r:
            _sum[o] = nums[l - 1]
            return 
        
        mid = l + r >> 1
        if idx <= mid: update(o << 1, l, mid, index, val)
        if idx > mid: update(o << 1 | 1, mid + 1, index, val)
        # 维护当前节点的信息，比如求和，求最大/小值
            
    
    def update(o: int, l: int, r: int, L: int, R: int) -> None:
        if L <= l and r <= R:
            # 更新当前节点o的信息
            return
        mid = l + r >> 1
        if L <= mid:
            update(o << 2, l, mid, L, R) # 左子树
        if mid < R:
            update(o << 2 | 1, mid + 1, r, L, R) # 右子树
        # 维护当前节点的信息，比如求和，求最大/小值

    # lazy tag
    def update(o: int, l: int, r: int, L: int, R: int, add: int) -> None:
        if L <= l and r <= R:
            # 更新当前节点o的信息
            todo[o] += add
            return

        if todo[o] != 0: # 产生了传递，需要递归下去给左右儿子
            todo[o << 1] += todo[o]
            todo[o << 1 | 1] += todo[o]
            todo[o] = 0

        mid = l + r >> 1
        if L <= mid:
            update(o << 2, l, mid, L, R, add) # 左子树
        if mid < R:
            update(o << 2 | 1, mid + 1, r, L, R, add) # 右子树
        # 维护当前节点的信息，比如求和，求最大/小值
    
    def query(o: int, l: int, r: int, L: int, R: int) -> int:
        if L <= l and r <= R:
            return _sum[o]
        res = 0
        mid = l + r >> 1
        if L <= mid: 
            res += query(o << 1, l, mid, L, R)
        if mid < R:
            res += query(o << 1 | 1, mid + 1, r, L, R)
        return res 
```


- 模板题
[Q307] Range Sum Query - Mutable
> - 关键字，单点修改，区间查询，维护区间和，线段树的经典应用场景。
> - 时间复杂度，$`O(logn)`$。
> - 空间复杂度，$`O(n)`$。
>

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.n = len(nums)
        self.nums = nums
        self.sum = [0] * (4 * self.n)
        self._build(1, 1, self.n)

    def _build(self, o, l, r):
        if l == r:
            self.sum[o] = self.nums[l - 1] # 线段树下标从1开始
            return 
        mid = l + r >> 1
        self._build(o << 1, l, mid)
        self._build(o << 1 | 1, mid + 1, r)
        self.sum[o] = self.sum[o << 1] + self.sum[o << 1 | 1]
    

    def _update(self, o, l, r, idx, val):
        if l == r:
            self.sum[o] = val
            return 
        mid = l + r >> 1
        if idx <= mid:
            self._update(o << 1, l, mid, idx, val)
        if idx > mid:
            self._update(o << 1 | 1, mid + 1, r, idx, val)
        self.sum[o] = self.sum[o << 1] + self.sum[o << 1 | 1]
        

    def _query(self, o: int, l: int, r: int, L: int, R: int):
        if L <= l and r <= R:
            return self.sum[o]
        
        res = 0
        mid = l + r >> 1
        if L <= mid:
            res += self._query(o << 1, l, mid, L, R)
        if mid < R:
            res += self._query(o << 1 | 1, mid + 1, r, L, R)
        return res 

    def update(self, index: int, val: int) -> None:
        self._update(1, 1, self.n, index + 1, val)
        

    def sumRange(self, left: int, right: int) -> int:
        return self._query(1, 1, self.n, left + 1, right + 1)
```

#### 相关问题
[Q2286] Booking Concert Tickets in Groups
>

```python
class BookMyShow:

    def __init__(self, n: int, m: int):
        # self.sum = [0] * (2 << n.bit_length()) # 省一些空间，没有必要
        self.sum = [0] * (4 * n)
        self.min = [0] * (4 * n)
        self.n = n
        self.m = m
    
    # add(1, 1, n, idx, val) idx += val, 单点修改
    def add(self, o: int, l: int, r: int, idx: int, val: int):
        # 叶子，都是闭区间
        if l == r:
            self.sum[o] += val
            self.min[o] += val
            return

        mid = l + r >> 1
        if idx <= mid: # 递归左子树[l, mid]
            self.add(o << 1, l, mid, idx, val)
        else: # 递归右子树 [mid+1, r]
            self.add(o << 1 | 1, mid + 1, r, idx, val)
        # 递归完，左右区间的信息都得到了，当前区间的信息也得到了
        self.sum[o] = self.sum[o << 1] + self.sum[o << 1 | 1]
        self.min[o] = min(self.min[o << 1], self.min[o << 1 | 1])
    
    # 区间查询
    def query_sum(self, o: int, l: int, r: int, L: int, R: int):
        # 包含当前区间直接返回值
        if L <= l and r <= R:
            return self.sum[o]
        res = 0
        mid = l + r >> 1
        if L <= mid:
            res += self.query_sum(o << 1, l, mid, L, R)
        if mid < R:
            res += self.query_sum(o << 1 | 1, mid+1, r, L, R)
        return res
    
    # 返回[1,R]范围内 <= val的最小下标，不存在返回0
    def index(self, o: int, l: int, r: int, R: int, val: int):
        if self.min[o] > val:
            return 0 
        if l == r:
            return l 
        
        mid = l + r >> 1 
        if self.min[o << 1] <= val:
            return self.index(o << 1, l, mid, R, val)
        if R > mid:
            return self.index(o << 1 | 1, mid+1, r, R, val)
        return 0 # 左右都没有找到

    def gather(self, k: int, maxRow: int) -> List[int]:
        # [1, R]
        i = self.index(1, 1, self.n, maxRow + 1, self.m - k)
        if i == 0:
            return []
        seats = self.query_sum(1, 1, self.n, i, i)
        self.add(1, 1, self.n, i, k)
        return [i - 1, seats]

    def scatter(self, k: int, maxRow: int) -> bool:
        left_seats = (maxRow + 1) * self.m - self.query_sum(1, 1, self.n, 1, maxRow + 1)
        if left_seats < k:
            return False 
        # 从第一个没有填满的排开始
        i = self.index(1, 1, self.n, maxRow + 1, self.m - 1)
        while True:
            left_seats = self.m - self.query_sum(1, 1, self.n, i, i)
            if k <= left_seats:
                self.add(1, 1, self.n, i, k)
                return True 
            k -= left_seats
            self.add(1, 1, self.n, i, left_seats)
            i += 1
```

[//]: # 
   [Q307]: <https://leetcode.com/problems/range-sum-query-mutable/>
   [Q2286]: <https://leetcode.com/problems/booking-concert-tickets-in-groups/>
   [Q2286]: <https://leetcode.com/problems/booking-concert-tickets-in-groups/>
