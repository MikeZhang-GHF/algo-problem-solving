### 哈希

#### 核心思想

#### 哈希表

- 相关题目

  [Q2531] 使字符串总不同字符的数目相等
  > - 关键字，不同字符的个数，可以使用哈希表来统计
  > - 只有小写字母，可以直接枚举26x26，就可以将所有情况覆盖
  > - 计算交换的字母后的不同字母个数，基于变化量进行计算，考虑哪些因素影响不同字母的个数，进行分类讨论，交换的字母相同或不同，交换的字出去的字母的个数==1，还是>1，交换进来的字母是否出现在当前字符串

  ```python
  class Solution:
    def isItPossible(self, word1: str, word2: str) -> bool:
        # 哈希表
        c1 = Counter(word1)
        c2 = Counter(word2)

        # 计算交换字母后，字母不同，字符串不同字母的个数的变化
        # 基于len(cnt)计算变化量，如果交换出去的字母只有1个，长度-1，
        # 如果交换回来的字母是第一次出现的，长度+1
        diff = lambda cnt, x_out, x_in: len(cnt) - (x_out == 1) + (x_in not in cnt)

        # 枚举交换的两个字母x,y
        for x, c in c1.items():
            for y, d in c2.items():
                if x == y: # 交换的字母相同
                    if len(c1) == len(c2):
                        return True 
                elif diff(c1, c, y) == diff(c2, d, x):
                    return True
        return False
  ```

#### 字符串哈希, rolling hash

#### 核心思想
> 字符串放入哈希表，查找的时间复杂度是O(L)，L是字符串的长度。将输入映射到一个值域较小、可以方便比较的范围。
> - 在Hash函数值不一样的时候，两个字符串一定不一样
> - 在Hash函数值一样的时候，两个字符串不一定一样(但有大概率一样，且我们当然希望它们总是一样的)
> - 我们将 Hash 函数值一样但原字符串不一样的现象称为哈希碰撞

#### 代码模板
- 字符串哈希函数
```python
M = 10**9 + 7

def string_hash(s, p=1313):
    hash_value = 0
    for c in s:
        hash_value = (hash_value * p + ord(c)) % M
    return hash_value
```

```python
import hashlib

# 1. 使用库函数的字符串哈希函数，可以减少哈希碰撞
def string_hash(s):
    hash_obj = hashlib.sha256()
    hash_obj.update(s.encode('utf-8'))
    return int(hash_obj.hexdigest(), 16) & ((1 << 64) - 1) # mod 2**64
```

- 多次询问子串哈希
> 单次计算一个字符串的哈希值复杂度是O(L), L是字符串长度，如果需要多次询问一个字符串的子串的哈希值，每次重新计算效率低下。 
> 一般采用的方法是对于整个字符预先处理出每个前缀的哈希值，将哈希值看成一个$b$进制的数对$M$取模的结果，这样每次可以快速求出子串的哈希:
> 令$f_i(s)$表示$f(s[1..i])$，原串长度为$i$的前缀的哈希值，按照定义有$f_i(s) = s[1]\cdot{b^{i - 1}} + s[2]\cdot{b^{i - 2}} + \cdot\cdot\cdot + s[i-1]\cdot b + s[r]$
> 现在，我们想要用类似前缀和的方式快速求出$f(s[l..r])$, 按照定义有字符串$s[l..r]$的哈希值为$f_i(s[l..r]) = s[l]\cdot{b^{r - l}} + s[l+1]\cdot{b^{r - l - 1}} + \cdot\cdot\cdot + s[r-1]\cdot b + s[r]$
> 对比上面两个公式，$f(s[l..r]) = f_r(s) - f_{l-1}(s)\times b^{r-l+1}$
> 因此，我们利用这个公式就可以快速得到子串的哈希值。其中$b^{r-l+1}$可以$O(n)$预处理出来，然后$O(1)$查询。


[//]: #

  [Q2531]: <https://leetcode.cn/problems/make-number-of-distinct-characters-equal/description/>